Path: ./src/bus.rs

// Copyright (c) 2019-present Dmitry Stepanov and Fyrox Engine contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

//! Everything related to audio buses and audio bus graphs. See docs of [`AudioBus`] and [`AudioBusGraph`]
//! for more info and examples

use crate::effects::{Effect, EffectRenderTrait};
use crate::pool::{Handle, Pool, Ticket};
use std::fmt::{Debug, Formatter};

#[derive(Default, Clone)]
struct PingPongBuffer {
    buffer1: Vec<(f32, f32)>,
    buffer2: Vec<(f32, f32)>,
    first_is_input: bool,
}

impl Debug for PingPongBuffer {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("PingPongBuffer")
            .field("Buffer1", &format_args!("{:?} bytes", self.buffer1.len()))
            .field("Buffer2", &format_args!("{:?} bytes", self.buffer2.len()))
            .field("FirstIsInput", &self.first_is_input)
            .finish()
    }
}

impl PingPongBuffer {
    fn resize(&mut self, size: usize) {
        self.buffer1 = Vec::with_capacity(size);
        self.buffer2 = Vec::with_capacity(size);
        self.clear();
    }

    fn clear(&mut self) {
        self.buffer1.clear();
        self.buffer2.clear();
        for _ in 0..self.buffer1.capacity() {
            self.buffer1.push((0.0, 0.0));
            self.buffer2.push((0.0, 0.0));
        }
    }

    fn capacity(&self) -> usize {
        self.buffer1.capacity()
    }

    fn swap(&mut self) {
        self.first_is_input = !self.first_is_input;
    }

    #[allow(clippy::type_complexity)]
    fn input_output_buffers(&mut self) -> (&[(f32, f32)], &mut [(f32, f32)]) {
        if self.first_is_input {
            (&self.buffer1, &mut self.buffer2)
        } else {
            (&self.buffer2, &mut self.buffer1)
        }
    }

    fn input_ref(&self) -> &[(f32, f32)] {
        if self.first_is_input {
            &self.buffer1
        } else {
            &self.buffer2
        }
    }

    fn input_mut(&mut self) -> &mut [(f32, f32)] {
        if self.first_is_input {
            &mut self.buffer1
        } else {
            &mut self.buffer2
        }
    }
}

/// Audio bus is a top-level audio processing unit. It takes data from multiple audio sources and passes their
/// samples through a chain of effects. Output signal is then can be either sent to an audio playback device or
/// to some other audio bus and be processed again, but with different sound effects (this can be done via
/// [`AudioBusGraph`].
#[derive(Debug, Clone)]
pub struct AudioBus {
    pub(crate) name: String,
    effects: Vec<Effect>,
    gain: f32,

    child_buses: Vec<Handle<AudioBus>>,

    parent_bus: Handle<AudioBus>,

    ping_pong_buffer: PingPongBuffer,
}

impl Default for AudioBus {
    fn default() -> Self {
        Self {
            name: "Bus".to_string(),
            child_buses: Default::default(),
            effects: Default::default(),
            gain: 1.0,
            ping_pong_buffer: Default::default(),
            parent_bus: Default::default(),
        }
    }
}

impl AudioBus {
    /// Creates a new audio bus with the given name with no audio effects and unit gain. Produced audio bus must
    /// be added to an [`AudioBusGraph`] to take effect.
    pub fn new(name: String) -> Self {
        Self {
            name,
            ..Default::default()
        }
    }

    /// Sets a new name of the audio bus. Be careful when changing the name at runtime, each sound source is linked
    /// to a bus by its name (implicit binding), so when changing the name you should also change the output bus name
    /// of a sound source, that uses the bus.
    pub fn set_name<S: AsRef<str>>(&mut self, name: S) {
        name.as_ref().clone_into(&mut self.name);
    }

    /// Returns current name of the audio bus. Could be useful if you need to find all sound sources that uses the bus.
    pub fn name(&self) -> &str {
        &self.name
    }

    /// Returns a handle of the parent audio bus. Primary audio bus has no parent and will return ([`Handle::NONE`]).
    pub fn parent(&self) -> Handle<AudioBus> {
        self.parent_bus
    }

    /// Returns a list of handle to children audio buses.
    pub fn children(&self) -> &[Handle<AudioBus>] {
        &self.child_buses
    }

    /// Sets new gain of the audio bus.
    pub fn set_gain(&mut self, gain: f32) {
        self.gain = gain;
    }

    /// Returns current gain of the audio bus.
    pub fn gain(&self) -> f32 {
        self.gain
    }

    pub(crate) fn input_buffer(&mut self) -> &mut [(f32, f32)] {
        self.ping_pong_buffer.input_mut()
    }

    pub(crate) fn begin_render(&mut self, buffer_size: usize) {
        if self.ping_pong_buffer.capacity() < buffer_size {
            self.ping_pong_buffer.resize(buffer_size);
        } else {
            self.ping_pong_buffer.clear();
        }
    }

    fn apply_effects(&mut self) {
        // Pass through the chain of effects.
        for effect in self.effects.iter_mut() {
            let (input, output) = self.ping_pong_buffer.input_output_buffers();
            effect.render(input, output);
            self.ping_pong_buffer.swap();
        }
    }

    /// Adds new effect to the effects chain.
    pub fn add_effect(&mut self, effect: Effect) {
        self.effects.push(effect)
    }

    /// Removes an effect by the given handle.
    pub fn remove_effect(&mut self, index: usize) {
        self.effects.remove(index);
    }

    /// Returns a shared reference to an effect at the given handle.
    pub fn effect(&self, index: usize) -> Option<&Effect> {
        self.effects.get(index)
    }

    /// Returns mutable reference to effect at given handle.
    pub fn effect_mut(&mut self, index: usize) -> Option<&mut Effect> {
        self.effects.get_mut(index)
    }

    /// Returns an iterator over effects used by this audio bus.
    pub fn effects(&self) -> impl Iterator<Item = &Effect> {
        self.effects.iter()
    }

    /// Returns an iterator over effects used by this audio bus.
    pub fn effects_mut(&mut self) -> impl Iterator<Item = &mut Effect> {
        self.effects.iter_mut()
    }
}

/// Audio bus graph is a complex audio data processing entity; it allows you to route samples from
/// audio sources through a chain of audio buses or directly to an audio playback device. To get a
/// better understanding of how the audio graph works take a look the data flow diagram below:
///
/// ```text
///
/// ┌────────────┐                                                        ┌────────────┐
/// │            │                                                        │            │
/// │   Source1  ├────────────┐                                ┌──────────┤   Source2  │
/// │            │            │                                │          │            │
/// └────────────┘            │                                │          └────────────┘
///                           ▼                                ▼
/// ┌────────────┐      ┌────────────┐                  ┌────────────┐    ┌────────────┐
/// │            │      │            │                  │            │    │            │
/// │   Source3  ├─────►│    Bus1    │                  │    BusN    │◄───┤   Source4  │
/// │            │      ├────────────┤                  ├────────────┤    │            │
/// └────────────┘      │            │                  │            │    └────────────┘
///                     │  Effect1 │ │   ┌───────────┐  │  Effect1 │ │
///                     │          │ │   │           │  │          │ │
///                     │  Effect2 │ │   │  SourceN  │  │  Effect2 │ │
///                     │          │ │   │           │  │          │ │
///                     │  EffectN ▼ │   └─────┬─────┘  │  EffectN ▼ │
///                     │            │         │        │            │
///                     └─────┬──────┘         │        └─────┬──────┘
///                           │                │              │
///                           │                ▼              │
///                           │          ┌────────────┐       │
///                           │          │            │       │
///                           └─────────►│   Primary  │◄──────┘
///                                      ├────────────┤
///                                      │            │
///                                      │  Effect1 │ │
///                                      │          │ │
///                                      │  Effect2 │ │
///                                      │          │ │
///                                      │  EffectN ▼ │
///                                      │            │
///                                      └─────┬──────┘
///                                            │
///                                            │
///                                            ▼
///                               ┌───────────────────────────┐
///                               │                           │
///                               │       Output Device       │
///                               │                           │
///                               └───────────────────────────┘
///
/// ```
///
/// Each audio bus is backed with data (samples) by a set of sound sources (`Source1`, `Source2`, ..) of
/// current audio context. This data is then passed through a set of effects, which could include various
/// filters (lowpass, highpass, bandpass, shelf filters, etc.) and complex effects such as reverberation.
///
/// By default, each audio bus graph has a single audio bus called Primary. It is mandatory to at least one
/// audio bus. Primary bus is responsible for outputting the data to an audio playback device.
///
/// # Sound source binding
///
/// Each sound source binds to an audio bus using its name; this is so called implicit binding. While it may
/// look weird, it is actually very useful. Explicit binding requires you to know the exact handle of an
/// audio bus to which a sound is "attached". This makes it less convenient to re-route data from one bus to
/// another. Implicit binding is as much more effective: all you need to do is to set a new name of a bus
/// to which output the samples from a sound source and the engine will do the rest for you. A simple example
/// of a such binding is something like this:
///
/// ```rust
/// # use fyrox_sound::bus::AudioBus;
/// # use fyrox_sound::context::SoundContext;
/// # use fyrox_sound::source::SoundSourceBuilder;
/// let context = SoundContext::new();
/// let mut state = context.state();
///
/// let sfx_bus = AudioBus::new("SFX".to_string());
/// let bus_graph = state.bus_graph_mut();
/// let primary_bus = bus_graph.primary_bus_handle();
/// bus_graph.add_bus(sfx_bus, primary_bus);
///
/// // Create a source and implicitly bind to the SFX audio bus. By default each source
/// // is bound to the primary audio bus.
/// state.add_source(SoundSourceBuilder::new().with_bus("SFX").build().unwrap());
/// ```
///
/// If you delete an audio bus to which a bunch of sound sources is bound, then they will simply stop playing.
#[derive(Default, Debug, Clone)]
pub struct AudioBusGraph {
    buses: Pool<AudioBus>,
    root: Handle<AudioBus>,
}

impl AudioBusGraph {
    /// The name of the audio bus that output samples directly to an audio playback device.
    pub const PRIMARY_BUS: &'static str = "Primary";

    /// Creates a new audio bus graph. Sound context already has an audio graph instance, so calling
    /// this method is needed only for very specific cases (mostly tests).
    pub fn new() -> Self {
        let root = AudioBus::new(Self::PRIMARY_BUS.to_string());
        let mut buses = Pool::new();
        let root = buses.spawn(root);
        Self { buses, root }
    }

    /// Adds a new audio bus to the graph and attaches it to the given parent. `parent` handle must be
    /// valid, otherwise the method will panic. In most cases you can use primary bus as a parent.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use fyrox_sound::bus::{AudioBus, AudioBusGraph};
    ///
    /// // By default it has one primary audio bus.
    /// let mut graph = AudioBusGraph::new();
    ///
    /// // Add another bus to the graph and attach it to the primary bus.
    /// let primary_bus_handle = graph.primary_bus_handle();
    /// graph.add_bus(AudioBus::new("SFX".to_owned()), primary_bus_handle);
    ///
    /// ```
    pub fn add_bus(&mut self, mut bus: AudioBus, parent: Handle<AudioBus>) -> Handle<AudioBus> {
        bus.parent_bus = parent;
        let bus = self.buses.spawn(bus);
        self.buses[parent].child_buses.push(bus);
        bus
    }

    fn unlink_internal(&mut self, node_handle: Handle<AudioBus>) {
        // Replace parent handle of child
        let parent_handle =
            std::mem::replace(&mut self.buses[node_handle].parent_bus, Handle::NONE);

        // Remove child from parent's children list
        if let Some(parent) = self.buses.try_borrow_mut(parent_handle) {
            if let Some(i) = parent.children().iter().position(|h| *h == node_handle) {
                parent.child_buses.remove(i);
            }
        }
    }

    /// Attaches the `child` audio bus to the `parent` audio bus. **Important:** this method does not
    /// checks for any loops, adding any loops to the graph will cause infinite loop in the mixer thread.
    #[inline]
    pub fn link_buses(&mut self, child: Handle<AudioBus>, parent: Handle<AudioBus>) {
        self.unlink_internal(child);
        self.buses[child].parent_bus = parent;
        self.buses[parent].child_buses.push(child);
    }

    pub(crate) fn try_get_bus_input_buffer(&mut self, name: &str) -> Option<&mut [(f32, f32)]> {
        self.buses.iter_mut().find_map(|bus| {
            if bus.name == name {
                Some(bus.input_buffer())
            } else {
                None
            }
        })
    }

    /// Removes an audio bus at the given handle.
    pub fn remove_bus(&mut self, handle: Handle<AudioBus>) -> AudioBus {
        assert_ne!(handle, self.root);

        let bus = self.buses.free(handle);
        let parent_bus = &mut self.buses[bus.parent_bus];

        let position = parent_bus
            .child_buses
            .iter()
            .position(|h| *h == handle)
            .expect("Malformed bus graph!");
        parent_bus.child_buses.remove(position);

        bus
    }

    /// Returns a handle of the primary audio bus. Primary bus outputs its samples directly to an audio playback
    /// device.
    pub fn primary_bus_handle(&self) -> Handle<AudioBus> {
        self.root
    }

    /// Returns a reference to the primary audio bus.
    pub fn primary_bus_ref(&self) -> &AudioBus {
        &self.buses[self.root]
    }

    /// Returns a reference to the primary audio bus.
    pub fn primary_bus_mut(&mut self) -> &mut AudioBus {
        &mut self.buses[self.root]
    }

    /// Tries to borrow an audio bus by its handle.
    pub fn try_get_bus_ref(&self, handle: Handle<AudioBus>) -> Option<&AudioBus> {
        self.buses.try_borrow(handle)
    }

    /// Tries to borrow an audio bus by its handle.
    pub fn try_get_bus_mut(&mut self, handle: Handle<AudioBus>) -> Option<&mut AudioBus> {
        self.buses.try_borrow_mut(handle)
    }

    /// Returns total amount of audio buses in the graph.
    pub fn len(&self) -> usize {
        self.buses.alive_count() as usize
    }

    /// Checks if the graph is empty.
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    /// Tries to move out an audio bus with a promise that it will be returned back. See [`Pool::try_take_reserve`] method
    /// docs for more info.
    pub fn try_take_reserve_bus(
        &mut self,
        handle: Handle<AudioBus>,
    ) -> Option<(Ticket<AudioBus>, AudioBus)> {
        self.buses.try_take_reserve(handle)
    }

    /// Puts the audio bus back to graph on its previous place by the given ticket. See [`Pool::put_back`] method docs
    /// for more info.
    pub fn put_bus_back(&mut self, ticket: Ticket<AudioBus>, bus: AudioBus) -> Handle<AudioBus> {
        self.buses.put_back(ticket, bus)
    }

    /// Forget an audio bus ticket making the respective handle free again. See [`Pool::forget_ticket`] method docs for
    /// more info.
    pub fn forget_bus_ticket(&mut self, ticket: Ticket<AudioBus>) {
        self.buses.forget_ticket(ticket)
    }

    /// Returns an iterator over each audio bus in the graph.
    pub fn buses_iter(&self) -> impl Iterator<Item = &AudioBus> {
        self.buses.iter()
    }

    /// Returns an iterator over each audio bus in the graph.
    pub fn buses_iter_mut(&mut self) -> impl Iterator<Item = &mut AudioBus> {
        self.buses.iter_mut()
    }

    /// Returns an iterator yielding a pair of handle and a reference to each audio bus in the graph.
    pub fn buses_pair_iter(&self) -> impl Iterator<Item = (Handle<AudioBus>, &AudioBus)> {
        self.buses.pair_iter()
    }

    /// Returns an iterator yielding a pair of handle and a reference to each audio bus in the graph.
    pub fn buses_pair_iter_mut(
        &mut self,
    ) -> impl Iterator<Item = (Handle<AudioBus>, &mut AudioBus)> {
        self.buses.pair_iter_mut()
    }

    pub(crate) fn begin_render(&mut self, output_device_buffer_size: usize) {
        for bus in self.buses.iter_mut() {
            bus.begin_render(output_device_buffer_size);
        }
    }

    pub(crate) fn end_render(&mut self, output_device_buffer: &mut [(f32, f32)]) {
        let mut leafs = Vec::new();
        for (handle, bus) in self.buses.pair_iter_mut() {
            bus.apply_effects();

            if bus.child_buses.is_empty() {
                leafs.push(handle);
            }
        }

        for mut leaf in leafs {
            while leaf.is_some() {
                let ctx = self.buses.begin_multi_borrow();

                let leaf_ref = ctx.try_get_mut(leaf).expect("Malformed bus graph!");

                let input_buffer = leaf_ref.ping_pong_buffer.input_ref();
                let leaf_gain = leaf_ref.gain;
                let mut parent_buffer = ctx.try_get_mut(leaf_ref.parent_bus);
                let output_buffer = parent_buffer
                    .as_mut()
                    .map(|parent| parent.ping_pong_buffer.input_mut())
                    // Special case for the root bus - it writes directly to the output device buffer.
                    .unwrap_or(&mut *output_device_buffer);
                for ((input_left, input_right), (output_left, output_right)) in
                    input_buffer.iter().zip(output_buffer)
                {
                    *output_left += *input_left * leaf_gain;
                    *output_right += *input_right * leaf_gain;
                }

                leaf = leaf_ref.parent_bus;
            }
        }
    }
}

#[cfg(test)]
mod test {
    use crate::{
        bus::{AudioBus, AudioBusGraph},
        effects::{Attenuate, Effect},
    };

    #[test]
    fn test_multi_bus_data_flow() {
        let mut output_buffer = [(0.0f32, 0.0f32)];

        let mut graph = AudioBusGraph::new();

        let bus1 = graph.add_bus(AudioBus::new("Bus1".to_string()), graph.root);
        let bus2 = graph.add_bus(AudioBus::new("Bus2".to_string()), bus1);

        graph.begin_render(output_buffer.len());

        // Simulate output of sound sources to each bus.
        for (left, right) in graph.buses[bus1].input_buffer() {
            *left = 1.0;
            *right = 1.0;
        }

        for (left, right) in graph.buses[bus2].input_buffer() {
            *left = 1.0;
            *right = 1.0;
        }

        graph.end_render(&mut output_buffer);

        assert_eq!(output_buffer[0], (2.0, 2.0));
    }

    #[test]
    fn test_primary_bus_data_flow() {
        let mut output_buffer = [(0.0f32, 0.0f32)];

        let mut graph = AudioBusGraph::new();

        graph.begin_render(output_buffer.len());

        // Simulate output of sound sources to each bus.
        for (left, right) in graph.buses[graph.root].input_buffer() {
            *left = 1.0;
            *right = 1.0;
        }

        graph.end_render(&mut output_buffer);

        assert_eq!(output_buffer[0], (1.0, 1.0));
    }

    #[test]
    fn test_multi_bus_data_flow_with_effects() {
        let mut output_buffer = [(0.0f32, 0.0f32)];

        let mut graph = AudioBusGraph::new();

        let mut bus1 = AudioBus::new("Bus1".to_string());
        bus1.add_effect(Effect::Attenuate(Attenuate::new(0.5)));
        bus1.add_effect(Effect::Attenuate(Attenuate::new(0.5)));

        let bus1 = graph.add_bus(bus1, graph.root);

        let mut bus2 = AudioBus::new("Bus2".to_string());
        bus2.add_effect(Effect::Attenuate(Attenuate::new(0.5)));
        let bus2 = graph.add_bus(bus2, bus1);

        graph.begin_render(output_buffer.len());

        // Simulate output of sound sources to each bus.
        for (left, right) in graph.buses[bus1].input_buffer() {
            *left = 1.0;
            *right = 1.0;
        }

        for (left, right) in graph.buses[bus2].input_buffer() {
            *left = 1.0;
            *right = 1.0;
        }

        graph.end_render(&mut output_buffer);

        assert_eq!(output_buffer[0], (0.75, 0.75));
    }
}


Path: ./src/effects/mod.rs


use strum_macros::{AsRefStr, EnumString, VariantNames};

/// Attenuation effect.
#[derive(Debug, Clone, PartialEq)]
pub struct Attenuate {
    gain: f32,
}

impl Default for Attenuate {
    fn default() -> Self {
        Self { gain: 1.0 }
    }
}

impl Attenuate {
    /// Creates new attenuation effect.
    pub fn new(gain: f32) -> Self {
        Self {
            gain: gain.max(0.0),
        }
    }
}

impl EffectRenderTrait for Attenuate {
    fn render(&mut self, input: &[(f32, f32)], output: &mut [(f32, f32)]) {
        for ((input_left, input_right), (output_left, output_right)) in
            input.iter().zip(output.iter_mut())
        {
            *output_left = *input_left * self.gain;
            *output_right = *input_right * self.gain;
        }
    }
}

/// Effects is a digital signal processing (DSP) unit that transforms input signal in a specific way.
/// For example, [`LowPassFilterEffect`] could be used to muffle audio sources; to create "underwater"
/// effect.
#[derive(Debug, Clone, PartialEq, AsRefStr, EnumString, VariantNames)]
pub enum Effect {
    /// See [`Attenuate`] docs for more info.
    Attenuate(Attenuate),
}

impl Default for Effect {
    fn default() -> Self {
        Effect::Attenuate(Default::default())
    }
}

pub(crate) trait EffectRenderTrait {
    fn render(&mut self, input: &[(f32, f32)], output: &mut [(f32, f32)]);
}

macro_rules! static_dispatch {
    ($self:ident, $func:ident, $($args:expr),*) => {
        match $self {
            Effect::Attenuate(v) => v.$func($($args),*),
        }
    };
}

impl EffectRenderTrait for Effect {
    fn render(&mut self, input: &[(f32, f32)], output: &mut [(f32, f32)]) {
        static_dispatch!(self, render, input, output)
    }
}


Path: ./src/lib.rs

use glam::{Mat3, Vec3};
use strum_macros::{AsRefStr, EnumString, VariantNames};

use std::error::Error;
use std::sync::{Arc, Mutex, MutexGuard};
use std::time::{Duration, Instant};

pub mod pool;
use pool::handle::Handle;
use pool::Pool;
use pool::Ticket;

pub mod source;
use source::{SoundSource, Status};
pub mod buffer;
pub mod bus;
use bus::AudioBusGraph;

pub mod effects;

pub const SAMPLE_RATE: u32 = 44100;
pub const SAMPLES_PER_CHANNEL: usize = 513 * 4;

/// Sound engine manages contexts, feeds output device with data. Sound engine instance can be cloned,
/// however this is always a "shallow" clone, because actual sound engine data is wrapped in Arc.
#[derive(Clone)]
pub struct SoundEngine(Arc<Mutex<SoundEngineState>>);

/// Internal state of the sound engine.
pub struct SoundEngineState {
    contexts: Vec<SoundContext>,
    output_device: Option<tinyaudio::OutputDevice>,
}

impl SoundEngine {
    /// Creates new instance of the sound engine. It is possible to have multiple engines running at
    /// the same time, but you shouldn't do this because you can create multiple contexts which
    /// should cover 99% of use cases.
    pub fn new() -> Result<Self, Box<dyn Error>> {
        let engine = Self::without_device();
        engine.initialize_audio_output_device()?;
        Ok(engine)
    }

    /// Creates new instance of a sound engine without OS audio output device (so called headless mode).
    /// The user should periodically run [`State::render`] if they want to implement their own sample sending
    /// method to an output device (or a file, etc.).
    pub fn without_device() -> Self {
        Self(Arc::new(Mutex::new(SoundEngineState {
            contexts: Default::default(),
            output_device: None,
        })))
    }

    /// Tries to initialize default audio output device.
    pub fn initialize_audio_output_device(&self) -> Result<(), Box<dyn Error>> {
        let state = self.clone();

        let device = tinyaudio::run_output_device(
            tinyaudio::OutputDeviceParameters {
                sample_rate: SAMPLE_RATE as usize,
                channels_count: 2,
                channel_sample_count: SAMPLES_PER_CHANNEL,
            },
            {
                move |buf| {
                    // SAFETY: This is safe as long as channels count above is 2.
                    let data = unsafe {
                        std::slice::from_raw_parts_mut(
                            buf.as_mut_ptr() as *mut (f32, f32),
                            buf.len() / 2,
                        )
                    };

                    state.state().render(data);
                }
            },
        )?;

        self.state().output_device = Some(device);

        Ok(())
    }

    /// Destroys current audio output device (if any).
    pub fn destroy_audio_output_device(&self) {
        self.state().output_device = None;
    }

    /// Provides direct access to actual engine data.
    pub fn state(&self) -> MutexGuard<SoundEngineState> {
        self.0.lock().unwrap()
    }
}

impl SoundEngineState {
    /// Adds new context to the engine. Each context must be added to the engine to emit
    /// sounds.
    pub fn add_context(&mut self, context: SoundContext) {
        self.contexts.push(context);
    }

    /// Removes a context from the engine. Removed context will no longer produce any sound.
    pub fn remove_context(&mut self, context: SoundContext) {
        if let Some(position) = self.contexts.iter().position(|c| c == &context) {
            self.contexts.remove(position);
        }
    }

    /// Removes all contexts from the engine.
    pub fn remove_all_contexts(&mut self) {
        self.contexts.clear()
    }

    /// Checks if a context is registered in the engine.
    pub fn has_context(&self, context: &SoundContext) -> bool {
        self.contexts
            .iter()
            .any(|c| Arc::ptr_eq(c.state.as_ref().unwrap(), context.state.as_ref().unwrap()))
    }

    /// Returns a reference to context container.
    pub fn contexts(&self) -> &[SoundContext] {
        &self.contexts
    }

    /// Returns the length of buf to be passed to [`Self::render()`].
    pub fn render_buffer_len() -> usize {
        SAMPLES_PER_CHANNEL
    }

    /// Renders the sound into buf. The buf must have at least [`Self::render_buffer_len()`]
    /// elements. This method must be used if and only if the engine was created via
    /// [`SoundEngine::without_device`].
    ///
    /// ## Deadlocks
    ///
    /// This method internally locks added sound contexts so it must be called when all the contexts
    /// are unlocked or you'll get a deadlock.
    pub fn render(&mut self, buf: &mut [(f32, f32)]) {
        buf.fill((0.0, 0.0));
        self.render_inner(buf);
    }

    fn render_inner(&mut self, buf: &mut [(f32, f32)]) {
        for context in self.contexts.iter_mut() {
            context.state().render(buf);
        }
    }
}

/// See module docs.
#[derive(Clone, Default, Debug)]
pub struct SoundContext {
    pub(crate) state: Option<Arc<Mutex<SoundContextState>>>,
}

impl PartialEq for SoundContext {
    fn eq(&self, other: &Self) -> bool {
        Arc::ptr_eq(self.state.as_ref().unwrap(), other.state.as_ref().unwrap())
    }
}

/// Internal state of context.
#[derive(Default, Debug, Clone)]
pub struct SoundContextState {
    sources: Pool<SoundSource>,
    listener: Listener,
    render_duration: Duration,
    renderer: Renderer,
    bus_graph: AudioBusGraph,
    paused: bool,
}

impl SoundContextState {
    /// Extracts a source from the context and reserves its handle. It is used to temporarily take
    /// ownership over source, and then put node back using given ticket.
    pub fn take_reserve(
        &mut self,
        handle: Handle<SoundSource>,
    ) -> (Ticket<SoundSource>, SoundSource) {
        self.sources.take_reserve(handle)
    }

    /// Puts source back by given ticket.
    pub fn put_back(
        &mut self,
        ticket: Ticket<SoundSource>,
        node: SoundSource,
    ) -> Handle<SoundSource> {
        self.sources.put_back(ticket, node)
    }

    /// Makes source handle vacant again.
    pub fn forget_ticket(&mut self, ticket: Ticket<SoundSource>) {
        self.sources.forget_ticket(ticket)
    }

    /// Pause/unpause the sound context. Paused context won't play any sounds.
    pub fn pause(&mut self, pause: bool) {
        self.paused = pause;
    }

    /// Returns true if the sound context is paused, false - otherwise.
    pub fn is_paused(&self) -> bool {
        self.paused
    }

    /// Normalizes given frequency using context's sampling rate. Normalized frequency then can be used
    /// to create filters.
    pub fn normalize_frequency(&self, f: f32) -> f32 {
        f / SAMPLE_RATE as f32
    }

    /// Returns amount of time context spent on rendering all sound sources.
    pub fn full_render_duration(&self) -> Duration {
        self.render_duration
    }

    /// Sets new renderer.
    pub fn set_renderer(&mut self, renderer: Renderer) -> Renderer {
        std::mem::replace(&mut self.renderer, renderer)
    }

    /// Returns shared reference to current renderer.
    pub fn renderer(&self) -> &Renderer {
        &self.renderer
    }

    /// Returns mutable reference to current renderer.
    pub fn renderer_mut(&mut self) -> &mut Renderer {
        &mut self.renderer
    }

    /// Adds new sound source and returns handle of it by which it can be accessed later on.
    pub fn add_source(&mut self, source: SoundSource) -> Handle<SoundSource> {
        self.sources.spawn(source)
    }

    /// Removes sound source from the context.
    pub fn remove_source(&mut self, source: Handle<SoundSource>) {
        self.sources.free(source);
    }

    /// Returns shared reference to a pool with all sound sources.
    pub fn sources(&self) -> &Pool<SoundSource> {
        &self.sources
    }

    /// Returns mutable reference to a pool with all sound sources.
    pub fn sources_mut(&mut self) -> &mut Pool<SoundSource> {
        &mut self.sources
    }

    /// Returns shared reference to sound source at given handle. If handle is invalid, this method will panic.
    pub fn source(&self, handle: Handle<SoundSource>) -> &SoundSource {
        self.sources.borrow(handle)
    }

    /// Checks whether a handle to a sound source is valid or not.
    pub fn is_valid_handle(&self, handle: Handle<SoundSource>) -> bool {
        self.sources.is_valid_handle(handle)
    }

    /// Returns mutable reference to sound source at given handle. If handle is invalid, this method will panic.
    pub fn source_mut(&mut self, handle: Handle<SoundSource>) -> &mut SoundSource {
        self.sources.borrow_mut(handle)
    }

    /// Returns mutable reference to sound source at given handle. If handle is invalid, this method will panic.
    pub fn try_get_source_mut(&mut self, handle: Handle<SoundSource>) -> Option<&mut SoundSource> {
        self.sources.try_borrow_mut(handle)
    }

    /// Returns shared reference to listener. Engine has only one listener.
    pub fn listener(&self) -> &Listener {
        &self.listener
    }

    /// Returns mutable reference to listener. Engine has only one listener.
    pub fn listener_mut(&mut self) -> &mut Listener {
        &mut self.listener
    }

    /// Returns a reference to the audio bus graph.
    pub fn bus_graph_ref(&self) -> &AudioBusGraph {
        &self.bus_graph
    }

    /// Returns a reference to the audio bus graph.
    pub fn bus_graph_mut(&mut self) -> &mut AudioBusGraph {
        &mut self.bus_graph
    }

    pub(crate) fn render(&mut self, output_device_buffer: &mut [(f32, f32)]) {
        let last_time = Instant::now();

        if !self.paused {
            self.sources.retain(|source| {
                let done = source.is_play_once() && source.status() == Status::Stopped;
                !done
            });

            self.bus_graph.begin_render(output_device_buffer.len());

            // Render sounds to respective audio buses.
            for source in self
                .sources
                .iter_mut()
                .filter(|s| s.status() == Status::Playing)
            {
                if let Some(bus_input_buffer) = self.bus_graph.try_get_bus_input_buffer(&source.bus)
                {
                    source.render(output_device_buffer.len());

                    match self.renderer {
                        Renderer::Default => {
                            // Simple rendering path. Much faster (4-5 times) than HRTF path.
                            render_source_default(source, &self.listener, bus_input_buffer);
                        }
                    }
                }
            }

            self.bus_graph.end_render(output_device_buffer);
        }

        self.render_duration = Instant::now().duration_since(last_time);
    }
}

impl SoundContext {
    /// Creates new instance of context. Internally context starts new thread which will call render all
    /// sound source and send samples to default output device. This method returns `Arc<Mutex<Context>>`
    /// because separate thread also uses context.
    pub fn new() -> Self {
        Self {
            state: Some(Arc::new(Mutex::new(SoundContextState {
                sources: Pool::new(),
                listener: Listener::new(),
                render_duration: Default::default(),
                renderer: Renderer::Default,
                bus_graph: AudioBusGraph::new(),
                paused: false,
            }))),
        }
    }

    /// Returns internal state of the context.
    ///
    /// ## Deadlocks
    ///
    /// This method internally locks a mutex, so if you'll try to do something like this:
    ///
    /// ```no_run
    /// # use fyrox_sound::context::SoundContext;
    /// # let ctx = SoundContext::new();
    /// let state = ctx.state();
    /// // Do something
    /// // ...
    /// ctx.state(); // This will cause a deadlock.
    /// ```
    ///
    /// You'll get a deadlock, so general rule here is to not store result of this method
    /// anywhere.
    pub fn state(&self) -> MutexGuard<'_, SoundContextState> {
        self.state.as_ref().unwrap().lock().unwrap()
    }

    /// Creates deep copy instead of shallow which is done by clone().
    pub fn deep_clone(&self) -> SoundContext {
        SoundContext {
            state: Some(Arc::new(Mutex::new(self.state().clone()))),
        }
    }

    /// Returns true if context is corrupted.
    pub fn is_invalid(&self) -> bool {
        self.state.is_none()
    }
}

#[derive(Debug, Clone, AsRefStr, EnumString, VariantNames)]
pub enum Renderer {
    /// Stateless default renderer.
    Default,
}

impl Default for Renderer {
    fn default() -> Self {
        Self::Default
    }
}


/// See module docs.
#[derive(Debug, Clone)]
pub struct Listener {
    basis: Mat3,
    position: Vec3,
}

impl Default for Listener {
    fn default() -> Self {
        Self::new()
    }
}

impl Listener {
    pub(crate) fn new() -> Self {
        Self {
            basis: Mat3::IDENTITY,
            position: Vec3::new(0.0, 0.0, 0.0),
        }
    }

    /// Sets new basis from given vectors in left-handed coordinate system.
    /// See `set_basis` for more info.
    pub fn set_orientation_lh(&mut self, look: Vec3, up: Vec3) {
        self.basis = Mat3::from_cols(look.cross(up), up, look)
    }

    /// Sets new basis from given vectors in right-handed coordinate system.
    /// See `set_basis` for more info.
    pub fn set_orientation_rh(&mut self, look: Vec3, up: Vec3) {
        self.basis = Mat3::from_cols(up.cross(look), up, look)
    }

    /// Sets arbitrary basis. Basis defines orientation of the listener in space.
    /// In your application you can take basis of camera in world coordinates and
    /// pass it to this method. If you using HRTF, make sure your basis is in
    /// right-handed coordinate system! You can make fake right-handed basis from
    /// left handed, by inverting Z axis. It is fake because it will work only for
    /// positions (engine interested in positions only), but not for rotation, shear
    /// etc.
    ///
    /// # Notes
    ///
    /// Basis must have mutually perpendicular axes.
    ///
    /// ```
    /// use fyrox_sound::listener::Listener;
    /// use fyrox_sound::algebra::{Mat3, UnitQuaternion, Vec3};
    /// use fyrox_sound::math::{Matrix4Ext};
    ///
    /// fn orient_listener(listener: &mut Listener) {
    ///     let basis = UnitQuaternion::from_axis_angle(&Vec3::y_axis(), 45.0f32.to_radians()).to_homogeneous().basis();
    ///     listener.set_basis(basis);
    /// }
    /// ```
    pub fn set_basis(&mut self, matrix: Mat3) {
        self.basis = matrix;
    }

    /// Returns shared reference to current basis.
    pub fn basis(&self) -> &Mat3 {
        &self.basis
    }

    /// Sets current position in world space.
    pub fn set_position(&mut self, position: Vec3) {
        self.position = position;
    }

    /// Returns position of listener.
    pub fn position(&self) -> Vec3 {
        self.position
    }

    /// Returns up axis from basis. up
    pub fn up_axis(&self) -> Vec3 {
        let m = self.basis.to_cols_array();
        Vec3::new(
            m[3],
            m[4],
            m[5],
        )
    }

    /// Returns look axis from basis. look
    pub fn look_axis(&self) -> Vec3 {
        let m = self.basis.to_cols_array();
        Vec3::new(
            m[6],
            m[7],
            m[8],
        )
    }

    /// Returns ear axis from basis. side
    pub fn ear_axis(&self) -> Vec3 {
        let m = self.basis.to_cols_array();
        Vec3::new(
            m[0],
            m[1],
            m[2],
        )
    }
}


fn render_with_params(
    source: &mut SoundSource,
    left_gain: f32,
    right_gain: f32,
    mix_buffer: &mut [(f32, f32)],
) {
    let last_left_gain = *source.last_left_gain.get_or_insert(left_gain);
    let last_right_gain = *source.last_right_gain.get_or_insert(right_gain);

    if last_left_gain != left_gain || last_right_gain != right_gain {
        let step = 1.0 / mix_buffer.len() as f32;
        let mut t = 0.0;
        for ((out_left, out_right), &(raw_left, raw_right)) in
            mix_buffer.iter_mut().zip(source.frame_samples())
        {
            // Interpolation of gain is very important to remove clicks which appears
            // when gain changes by significant value between frames.
            *out_left += lerp(last_left_gain, left_gain, t) * raw_left;
            *out_right += lerp(last_right_gain, right_gain, t) * raw_right;

            t += step;
        }
    } else {
        for ((out_left, out_right), &(raw_left, raw_right)) in
            mix_buffer.iter_mut().zip(source.frame_samples())
        {
            // Optimize the common case when the gain did not change since the last call.
            *out_left += left_gain * raw_left;
            *out_right += right_gain * raw_right;
        }
    }
}

pub(crate) fn render_source_default(
    source: &mut SoundSource,
    listener: &Listener,
    mix_buffer: &mut [(f32, f32)],
) {
    let panning = lerp(
        source.panning(),
        source.calculate_panning(listener),
        source.spatial_blend(),
    );
    let gain = 1.0 * source.gain();
    let left_gain = gain * (1.0 + panning);
    let right_gain = gain * (1.0 - panning);
    render_with_params(source, left_gain, right_gain, mix_buffer);
    source.last_left_gain = Some(left_gain);
    source.last_right_gain = Some(right_gain);
}

pub(crate) fn render_source_2d_only(source: &mut SoundSource, mix_buffer: &mut [(f32, f32)]) {
    let gain = (1.0 - source.spatial_blend()) * source.gain();
    let left_gain = gain * (1.0 + source.panning());
    let right_gain = gain * (1.0 - source.panning());
    render_with_params(source, left_gain, right_gain, mix_buffer);
    source.last_left_gain = Some(left_gain);
    source.last_right_gain = Some(right_gain);
}

pub fn lerp(a: f32, b: f32, t: f32) -> f32 {
    a + (b - a) * t
}


Path: ./src/main.rs

fn main() {
    
}

Path: ./src/source.rs

use std::time::Duration;

use glam::Vec3;

use crate::{buffer::Buffer, Listener};

/// Status (state) of sound source.
#[derive(Eq, PartialEq, Copy, Clone, Debug)]
#[repr(u32)]
pub enum Status {
    /// Sound is stopped - it won't produces any sample and won't load mixer. This is default
    /// state of all sound sources.
    Stopped = 0,

    /// Sound is playing.
    Playing = 1,

    /// Sound is paused, it can stay in this state any amount if time. Playback can be continued by
    /// setting `Playing` status.
    Paused = 2,
}

/// See module info.
#[derive(Debug, Clone)]
pub struct SoundSource {
    name: String,
    buffer: Option<Buffer>,
    // Read position in the buffer in samples. Differs from `playback_pos` if buffer is streaming.
    // In case of streaming buffer its maximum value will be some fixed value which is
    // implementation defined. It can be less than zero, this happens when we are in the process
    // of reading next block in streaming buffer (see also prev_buffer_sample).
    buf_read_pos: f64,
    // Real playback position in samples.
    playback_pos: f64,
    panning: f32,
    pitch: f64,
    gain: f32,
    looping: bool,
    spatial_blend: f32,
    // Important coefficient for runtime resampling. It is used to modify playback speed
    // of a source in order to match output device sampling rate. PCM data can be stored
    // in various sampling rates (22050 Hz, 44100 Hz, 88200 Hz, etc.) but output device
    // is running at fixed sampling rate (usually 44100 Hz). For example if we we'll feed
    // data to device with rate of 22050 Hz but device is running at 44100 Hz then we'll
    // hear that sound will have high pitch (2.0), to fix that we'll just pre-multiply
    // playback speed by 0.5.
    // However such auto-resampling has poor quality, but it is fast.
    resampling_multiplier: f64,
    status: Status,
    pub(crate) bus: String,
    play_once: bool,
    // Here we use Option because when source is just created it has no info about it
    // previous left and right channel gains. We can't set it to 1.0 for example
    // because it would give incorrect results: a sound would just start as loud as it
    // can be with no respect to real distance attenuation (or what else affects channel
    // gain). So if these are None engine will set correct values first and only then it
    // will start interpolation of gain.
    pub(crate) last_left_gain: Option<f32>,
    pub(crate) last_right_gain: Option<f32>,
    pub(crate) frame_samples: Vec<(f32, f32)>,
    // This sample is used when doing linear interpolation between two blocks of streaming buffer.
    prev_buffer_sample: (f32, f32),
    radius: f32,
    position: Vec3,
    max_distance: f32,
    rolloff_factor: f32,
    // Some data that needed for iterative overlap-save convolution.
    pub(crate) prev_left_samples: Vec<f32>,
    pub(crate) prev_right_samples: Vec<f32>,
    pub(crate) prev_sampling_vector: Vec3,
    pub(crate) prev_distance_gain: Option<f32>,
}

impl SoundSource {
    /// Sets new name of the sound source.
    pub fn set_name<N: AsRef<str>>(&mut self, name: N) {
        name.as_ref().clone_into(&mut self.name);
    }

    /// Returns the name of the sound source.
    pub fn name(&self) -> &str {
        &self.name
    }

    /// Returns the name of the sound source.
    pub fn name_owned(&self) -> String {
        self.name.to_owned()
    }

    /// Sets spatial blend factor. It defines how much the source will be 2D and 3D sound at the same
    /// time. Set it to 0.0 to make the sound fully 2D and 1.0 to make it fully 3D. Middle values
    /// will make sound proportionally 2D and 3D at the same time.
    pub fn set_spatial_blend(&mut self, k: f32) {
        self.spatial_blend = k.clamp(0.0, 1.0);
    }

    /// Returns spatial blend factor.
    pub fn spatial_blend(&self) -> f32 {
        self.spatial_blend
    }

    /// Marks buffer for single play. It will be automatically destroyed when it will finish playing.
    ///
    /// # Notes
    ///
    /// Make sure you not using handles to "play once" sounds, attempt to get reference of "play once" sound
    /// may result in panic if source already deleted. Looping sources will never be automatically deleted
    /// because their playback never stops.
    pub fn set_play_once(&mut self, play_once: bool) {
        self.play_once = play_once;
    }

    /// Returns true if this source is marked for single play, false - otherwise.
    pub fn is_play_once(&self) -> bool {
        self.play_once
    }

    /// Sets new gain (volume) of sound. Value should be in 0..1 range, but it is not clamped
    /// and larger values can be used to "overdrive" sound.
    ///
    /// # Notes
    ///
    /// Physical volume has non-linear scale (logarithmic) so perception of sound at 0.25 gain
    /// will be different if logarithmic scale was used.
    pub fn set_gain(&mut self, gain: f32) -> &mut Self {
        self.gain = gain;
        self
    }

    /// Returns current gain (volume) of sound. Value is in 0..1 range.
    pub fn gain(&self) -> f32 {
        self.gain
    }

    /// Sets panning coefficient. Value must be in -1..+1 range. Where -1 - only left channel will be audible,
    /// 0 - both, +1 - only right.
    pub fn set_panning(&mut self, panning: f32) -> &mut Self {
        self.panning = panning.clamp(-1.0, 1.0);
        self
    }

    /// Returns current panning coefficient in -1..+1 range. For more info see `set_panning`. Default value is 0.
    pub fn panning(&self) -> f32 {
        self.panning
    }

    /// Returns status of sound source.
    pub fn status(&self) -> Status {
        self.status
    }

    /// Changes status to `Playing`.
    pub fn play(&mut self) -> &mut Self {
        self.status = Status::Playing;
        self
    }

    /// Changes status to `Paused`
    pub fn pause(&mut self) -> &mut Self {
        self.status = Status::Paused;
        self
    }

    /// Enabled or disables sound looping. Looping sound will never stop by itself, but can be stopped or paused
    /// by calling `stop` or `pause` methods. Useful for music, ambient sounds, etc.
    pub fn set_looping(&mut self, looping: bool) -> &mut Self {
        self.looping = looping;
        self
    }

    /// Returns looping status.
    pub fn is_looping(&self) -> bool {
        self.looping
    }

    /// Sets sound pitch. Defines "tone" of sounds. Default value is 1.0
    pub fn set_pitch(&mut self, pitch: f64) -> &mut Self {
        self.pitch = pitch.abs();
        self
    }

    /// Returns pitch of sound source.
    pub fn pitch(&self) -> f64 {
        self.pitch
    }

    /// Stops sound source. Automatically rewinds streaming buffers.
    pub fn stop(&mut self) -> anyhow::Result<()> {
        self.status = Status::Stopped;

        self.buf_read_pos = 0.0;
        self.playback_pos = 0.0;

        Ok(())
    }
    /// Sets position of source in world space.
    pub fn set_position(&mut self, position: Vec3) -> &mut Self {
        self.position = position;
        self
    }

    /// Returns positions of source.
    pub fn position(&self) -> Vec3 {
        self.position
    }

    /// Sets radius of imaginable sphere around source in which no distance attenuation is applied.
    pub fn set_radius(&mut self, radius: f32) -> &mut Self {
        self.radius = radius;
        self
    }

    /// Returns radius of source.
    pub fn radius(&self) -> f32 {
        self.radius
    }

    /// Sets rolloff factor. Rolloff factor is used in distance attenuation and has different meaning
    /// in various distance models. It is applicable only for InverseDistance and ExponentDistance
    /// distance models. See DistanceModel docs for formulae.
    pub fn set_rolloff_factor(&mut self, rolloff_factor: f32) -> &mut Self {
        self.rolloff_factor = rolloff_factor;
        self
    }

    /// Returns rolloff factor.
    pub fn rolloff_factor(&self) -> f32 {
        self.rolloff_factor
    }

    /// Sets maximum distance until which distance gain will be applicable. Basically it doing this
    /// min(max(distance, radius), max_distance) which clamps distance in radius..max_distance range.
    /// From listener's perspective this will sound like source has stopped decreasing its volume even
    /// if distance continue to grow.
    pub fn set_max_distance(&mut self, max_distance: f32) -> &mut Self {
        self.max_distance = max_distance;
        self
    }

    /// Returns max distance.
    pub fn max_distance(&self) -> f32 {
        self.max_distance
    }

    /// Sets new name of the target audio bus. The name must be valid, otherwise the sound won't play!
    /// Default is [`AudioBusGraph::PRIMARY_BUS`].
    pub fn set_bus<S: AsRef<str>>(&mut self, bus: S) {
        bus.as_ref().clone_into(&mut self.bus);
    }

    /// Return the name of the target audio bus.
    pub fn bus(&self) -> &str {
        &self.bus
    }

    pub(crate) fn calculate_panning(&self, listener: &Listener) -> f32 {
        (listener.position() - self.position)
            .try_normalize()
            // Fallback to look axis will give zero panning which will result in even
            // gain in each channels (as if there was no panning at all).
            .unwrap_or_else(|| listener.look_axis())
            .dot(listener.ear_axis())
    }

    pub(crate) fn calculate_sampling_vector(&self, listener: &Listener) -> Vec3 {
        let to_self = listener.position() - self.position;

        (*listener.basis() * to_self)
            .try_normalize()
            // This is ok to fallback to (0, 0, 1) vector because it's given
            // in listener coordinate system.
            .unwrap_or_else(|| Vec3::new(0.0, 0.0, 1.0))
    }

    /// Returns playback duration.
    pub fn playback_time(&self) -> Duration {
        if let Some(buffer) = self.buffer.as_ref() {
            return Duration::from_secs_f64(self.playback_pos / (buffer.sample_rate as f64));
        }

        Duration::from_secs(0)
    }

    /// Sets playback duration.
    pub fn set_playback_time(&mut self, time: Duration) {
        if let Some(buffer) = self.buffer.as_ref() {
            // Set absolute position first.
            self.playback_pos = (time.as_secs_f64() * buffer.sample_rate as f64)
                .clamp(0.0, buffer.duration().as_secs_f64());
            // Then adjust buffer read position.
            self.buf_read_pos = self.playback_pos;
            assert!(
                self.buf_read_pos * (buffer.channel_count as f64) < buffer.samples.len() as f64
            );
        }
    }

    pub(crate) fn render(&mut self, amount: usize) {
        if self.frame_samples.capacity() < amount {
            self.frame_samples = Vec::with_capacity(amount);
        }

        self.frame_samples.clear();

        if let Some(mut buffer) = self.buffer.clone() {
            if self.status == Status::Playing && !buffer.samples.is_empty() {
                self.render_playing(&mut buffer, amount);
            }
        }
        // Fill the remaining part of frame_samples.
        self.frame_samples.resize(amount, (0.0, 0.0));
    }

    fn render_playing(&mut self, buffer: &mut Buffer, amount: usize) {
        let mut count = 0;
        loop {
            count += self.render_until_block_end(buffer, amount - count);
            if count == amount {
                break;
            }

            let channel_count = buffer.channel_count;
            let len = buffer.samples.len();
            let mut end_reached = true;
            if end_reached {
                self.buf_read_pos = 0.0;
                self.playback_pos = 0.0;
                if !self.looping {
                    self.status = Status::Stopped;
                    return;
                }
            } else {
                self.buf_read_pos -= len as f64 / channel_count as f64;
            }
        }
    }

    // Renders until the end of the block or until amount samples is written and returns
    // the number of written samples.
    fn render_until_block_end(&mut self, buffer: &mut Buffer, mut amount: usize) -> usize {
        let step = self.pitch * self.resampling_multiplier;
        if step == 1.0 {
            if self.buf_read_pos < 0.0 {
                // This can theoretically happen if we change pitch on the fly.
                self.frame_samples.push(self.prev_buffer_sample);
                self.buf_read_pos = 0.0;
                amount -= 1;
            }
            // Fast-path for common case when there is no resampling and no pitch change.
            let from = self.buf_read_pos as usize;
            let buffer_len = buffer.samples.len() / buffer.channel_count;
            let rendered = (buffer_len - from).min(amount);
            if buffer.channel_count == 2 {
                for i in from..from + rendered {
                    self.frame_samples
                        .push((buffer.samples[i * 2], buffer.samples[i * 2 + 1]))
                }
            } else {
                for i in from..from + rendered {
                    self.frame_samples
                        .push((buffer.samples[i], buffer.samples[i]))
                }
            }
            self.buf_read_pos += rendered as f64;
            self.playback_pos += rendered as f64;
            rendered
        } else {
            self.render_until_block_end_resample(buffer, amount, step)
        }
    }

    // Does linear resampling while rendering until the end of the block.
    fn render_until_block_end_resample(
        &mut self,
        buffer: &mut Buffer,
        amount: usize,
        step: f64,
    ) -> usize {
        let mut rendered = 0;

        while self.buf_read_pos < 0.0 {
            // Interpolate between last sample of previous buffer and first sample of current
            // buffer. This is important, otherwise there will be quiet but audible pops
            // in the output.
            let w = (self.buf_read_pos - self.buf_read_pos.floor()) as f32;
            let cur_first_sample = if buffer.channel_count == 2 {
                (buffer.samples[0], buffer.samples[1])
            } else {
                (buffer.samples[0], buffer.samples[0])
            };
            let l = self.prev_buffer_sample.0 * (1.0 - w) + cur_first_sample.0 * w;
            let r = self.prev_buffer_sample.1 * (1.0 - w) + cur_first_sample.1 * w;
            self.frame_samples.push((l, r));
            self.buf_read_pos += step;
            self.playback_pos += step;
            rendered += 1;
        }

        // We want to keep global positions in f64, but use f32 in inner loops (this improves
        // code generation and performance at least on some systems), so we split the buf_read_pos
        // into integer and f32 part.
        let buffer_base_idx = self.buf_read_pos as usize;
        let mut buffer_rel_pos = (self.buf_read_pos - buffer_base_idx as f64) as f32;
        let start_buffer_rel_pos = buffer_rel_pos;
        let rel_step = step as f32;
        // We skip one last element because the hot loop resampling between current and next
        // element. Last elements are appended after the hot loop.
        let buffer_last = buffer.samples.len() / buffer.channel_count - 1;
        if buffer.channel_count == 2 {
            while rendered < amount {
                let (idx, w) = {
                    let idx = buffer_rel_pos as usize;
                    // This looks a bit complicated but fract() is quite a bit slower on x86,
                    // because it turns into a function call on targets < SSE4.1, unlike aarch64)
                    (idx + buffer_base_idx, buffer_rel_pos - idx as f32)
                };
                if idx >= buffer_last {
                    break;
                }
                let l = buffer.samples[idx * 2] * (1.0 - w) + buffer.samples[idx * 2 + 2] * w;
                let r = buffer.samples[idx * 2 + 1] * (1.0 - w) + buffer.samples[idx * 2 + 3] * w;
                self.frame_samples.push((l, r));
                buffer_rel_pos += rel_step;
                rendered += 1;
            }
        } else {
            while rendered < amount {
                let (idx, w) = {
                    let idx = buffer_rel_pos as usize;
                    // See comment above.
                    (idx + buffer_base_idx, buffer_rel_pos - idx as f32)
                };
                if idx >= buffer_last {
                    break;
                }
                let v = buffer.samples[idx] * (1.0 - w) + buffer.samples[idx + 1] * w;
                self.frame_samples.push((v, v));
                buffer_rel_pos += rel_step;
                rendered += 1;
            }
        }

        self.buf_read_pos += (buffer_rel_pos - start_buffer_rel_pos) as f64;
        self.playback_pos += (buffer_rel_pos - start_buffer_rel_pos) as f64;
        rendered
    }

    pub(crate) fn frame_samples(&self) -> &[(f32, f32)] {
        &self.frame_samples
    }
}

impl Drop for SoundSource {
    fn drop(&mut self) {
        if let Some(buffer) = self.buffer.as_ref() {}
    }
}


Path: ./src/pool/multiborrow.rs

// Copyright (c) 2019-present Dmitry Stepanov and Fyrox Engine contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use super::{Handle, PayloadContainer, Pool, RefCounter};
use std::{
    any::TypeId,
    cell::RefCell,
    cmp::Ordering,
    fmt::{Debug, Display, Formatter},
    marker::PhantomData,
    ops::{Deref, DerefMut},
};

pub struct Ref<'a, 'b, T>
where
    T: ?Sized,
{
    data: &'a T,
    ref_counter: &'a RefCounter,
    phantom: PhantomData<&'b ()>,
}

impl<T> Debug for Ref<'_, '_, T>
where
    T: ?Sized + Debug,
{
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        Debug::fmt(&self.data, f)
    }
}

impl<T> Deref for Ref<'_, '_, T>
where
    T: ?Sized,
{
    type Target = T;

    fn deref(&self) -> &Self::Target {
        self.data
    }
}

impl<T> Drop for Ref<'_, '_, T>
where
    T: ?Sized,
{
    fn drop(&mut self) {
        // SAFETY: This is safe, because this ref lifetime is managed by the borrow checker,
        // so it cannot outlive the pool record.
        unsafe {
            self.ref_counter.decrement();
        }
    }
}

pub struct RefMut<'a, 'b, T>
where
    T: ?Sized,
{
    data: &'a mut T,
    ref_counter: &'a RefCounter,
    phantom: PhantomData<&'b ()>,
}

impl<T> Debug for RefMut<'_, '_, T>
where
    T: ?Sized + Debug,
{
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        Debug::fmt(&self.data, f)
    }
}

impl<T> Deref for RefMut<'_, '_, T>
where
    T: ?Sized,
{
    type Target = T;

    fn deref(&self) -> &Self::Target {
        self.data
    }
}

impl<T> DerefMut for RefMut<'_, '_, T>
where
    T: ?Sized,
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.data
    }
}

impl<T> Drop for RefMut<'_, '_, T>
where
    T: ?Sized,
{
    fn drop(&mut self) {
        // SAFETY: This is safe, because this ref lifetime is managed by the borrow checker,
        // so it cannot outlive the pool record.
        unsafe {
            self.ref_counter.increment();
        }
    }
}

/// Multi-borrow context allows you to get as many **unique** references to elements in
/// a pool as you want.
pub struct MultiBorrowContext<'a, T, P = Option<T>>
where
    T: Sized,
    P: PayloadContainer<Element = T> + 'static,
{
    pool: &'a mut Pool<T, P>,
    free_indices: RefCell<Vec<u32>>,
}

#[derive(PartialEq)]
pub enum MultiBorrowError<T> {
    Empty(Handle<T>),
    NoSuchComponent(Handle<T>),
    MutablyBorrowed(Handle<T>),
    ImmutablyBorrowed(Handle<T>),
    InvalidHandleIndex(Handle<T>),
    InvalidHandleGeneration(Handle<T>),
}

impl<T> Debug for MultiBorrowError<T> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        Display::fmt(self, f)
    }
}

impl<T> Display for MultiBorrowError<T> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Empty(handle) => {
                write!(f, "There's no object at {handle} handle.")
            }
            Self::NoSuchComponent(handle) => write!(
                f,
                "An object at {handle} handle does not have such component.",
            ),
            Self::MutablyBorrowed(handle) => {
                write!(
                    f,
                    "An object at {handle} handle cannot be borrowed immutably, because it is \
                    already borrowed mutably."
                )
            }
            Self::ImmutablyBorrowed(handle) => {
                write!(
                    f,
                    "An object at {handle} handle cannot be borrowed mutably, because it is \
                    already borrowed immutably."
                )
            }
            Self::InvalidHandleIndex(handle) => {
                write!(
                    f,
                    "The index {} in {handle} handle is out of bounds.",
                    handle.index
                )
            }
            Self::InvalidHandleGeneration(handle) => {
                write!(
                    f,
                    "The generation {} in {handle} handle does not match the record's generation. \
                    It means that the object at the handle was freed and it position was taken \
                    by some other object.",
                    handle.generation
                )
            }
        }
    }
}

impl<T, P> Drop for MultiBorrowContext<'_, T, P>
where
    T: Sized,
    P: PayloadContainer<Element = T> + 'static,
{
    fn drop(&mut self) {
        self.pool
            .free_stack
            .extend_from_slice(&self.free_indices.borrow())
    }
}

impl<'a, T, P> MultiBorrowContext<'a, T, P>
where
    T: Sized,
    P: PayloadContainer<Element = T> + 'static,
{
    #[inline]
    pub fn new(pool: &'a mut Pool<T, P>) -> Self {
        Self {
            pool,
            free_indices: Default::default(),
        }
    }

    #[inline]
    fn try_get_internal<'b: 'a, C, F>(
        &'b self,
        handle: Handle<T>,
        func: F,
    ) -> Result<Ref<'a, 'b, C>, MultiBorrowError<T>>
    where
        C: ?Sized,
        F: FnOnce(&T) -> Result<&C, MultiBorrowError<T>>,
    {
        let Some(record) = self.pool.records_get(handle.index) else {
            return Err(MultiBorrowError::InvalidHandleIndex(handle));
        };

        if handle.generation != record.generation {
            return Err(MultiBorrowError::InvalidHandleGeneration(handle));
        }

        let current_ref_count = unsafe { record.ref_counter.get() };
        if current_ref_count < 0 {
            return Err(MultiBorrowError::MutablyBorrowed(handle));
        }

        // SAFETY: We've enforced borrowing rules by the previous check.
        let payload_container = unsafe { &*record.payload.0.get() };

        let Some(payload) = payload_container.as_ref() else {
            return Err(MultiBorrowError::Empty(handle));
        };

        unsafe {
            record.ref_counter.increment();
        }

        Ok(Ref {
            data: func(payload)?,
            ref_counter: &record.ref_counter,
            phantom: PhantomData,
        })
    }

    /// Tries to get a mutable reference to a pool element located at the given handle. The method could
    /// fail in three main reasons:
    ///
    /// 1) A reference to an element is already taken - returning multiple mutable references to the
    /// same element is forbidden by Rust safety rules.
    /// 2) You're trying to get more references that the context could handle (there is not enough space
    /// in the internal handles storage) - in this case you must increase `N`.
    /// 3) A given handle is invalid.
    #[inline]
    pub fn try_get<'b: 'a>(
        &'b self,
        handle: Handle<T>,
    ) -> Result<Ref<'a, 'b, T>, MultiBorrowError<T>> {
        self.try_get_internal(handle, |obj| Ok(obj))
    }

    #[inline]
    pub fn get<'b: 'a>(&'b self, handle: Handle<T>) -> Ref<'a, 'b, T> {
        self.try_get(handle).unwrap()
    }

    #[inline]
    fn try_get_mut_internal<'b: 'a, C, F>(
        &'b self,
        handle: Handle<T>,
        func: F,
    ) -> Result<RefMut<'a, 'b, C>, MultiBorrowError<T>>
    where
        C: ?Sized,
        F: FnOnce(&mut T) -> Result<&mut C, MultiBorrowError<T>>,
    {
        let Some(record) = self.pool.records_get(handle.index) else {
            return Err(MultiBorrowError::InvalidHandleIndex(handle));
        };

        if handle.generation != record.generation {
            return Err(MultiBorrowError::InvalidHandleGeneration(handle));
        }

        // SAFETY: It is safe to access the counter because of borrow checker guarantees that
        // the record is alive.
        let current_ref_count = unsafe { record.ref_counter.get() };
        match current_ref_count.cmp(&0) {
            Ordering::Less => {
                return Err(MultiBorrowError::MutablyBorrowed(handle));
            }
            Ordering::Greater => {
                return Err(MultiBorrowError::ImmutablyBorrowed(handle));
            }
            _ => (),
        }

        // SAFETY: We've enforced borrowing rules by the previous check.
        let payload_container = unsafe { &mut *record.payload.0.get() };

        let Some(payload) = payload_container.as_mut() else {
            return Err(MultiBorrowError::Empty(handle));
        };

        // SAFETY: It is safe to access the counter because of borrow checker guarantees that
        // the record is alive.
        unsafe {
            record.ref_counter.decrement();
        }

        Ok(RefMut {
            data: func(payload)?,
            ref_counter: &record.ref_counter,
            phantom: PhantomData,
        })
    }

    #[inline]
    pub fn try_get_mut<'b: 'a>(
        &'b self,
        handle: Handle<T>,
    ) -> Result<RefMut<'a, 'b, T>, MultiBorrowError<T>> {
        self.try_get_mut_internal(handle, |obj| Ok(obj))
    }

    #[inline]
    pub fn get_mut<'b: 'a>(&'b self, handle: Handle<T>) -> RefMut<'a, 'b, T> {
        self.try_get_mut(handle).unwrap()
    }

    #[inline]
    pub fn free(&self, handle: Handle<T>) -> Result<T, MultiBorrowError<T>> {
        let Some(record) = self.pool.records_get(handle.index) else {
            return Err(MultiBorrowError::InvalidHandleIndex(handle));
        };

        if handle.generation != record.generation {
            return Err(MultiBorrowError::InvalidHandleGeneration(handle));
        }

        // The record must be non-borrowed to be freed.
        // SAFETY: It is safe to access the counter because of borrow checker guarantees that
        // the record is alive.
        let current_ref_count = unsafe { record.ref_counter.get() };
        match current_ref_count.cmp(&0) {
            Ordering::Less => {
                return Err(MultiBorrowError::MutablyBorrowed(handle));
            }
            Ordering::Greater => {
                return Err(MultiBorrowError::ImmutablyBorrowed(handle));
            }
            _ => (),
        }

        // SAFETY: We've enforced borrowing rules by the previous check.
        let payload_container = unsafe { &mut *record.payload.0.get() };

        let Some(payload) = payload_container.take() else {
            return Err(MultiBorrowError::Empty(handle));
        };

        self.free_indices.borrow_mut().push(handle.index);

        Ok(payload)
    }
}

#[cfg(test)]
mod test {
    use super::MultiBorrowError;
    use crate::pool::Pool;

    #[derive(PartialEq, Clone, Copy, Debug)]
    struct MyPayload(u32);

    #[test]
    fn test_multi_borrow_context() {
        let mut pool = Pool::<MyPayload>::new();

        let mut val_a = MyPayload(123);
        let mut val_b = MyPayload(321);
        let mut val_c = MyPayload(42);
        let val_d = MyPayload(666);

        let a = pool.spawn(val_a);
        let b = pool.spawn(val_b);
        let c = pool.spawn(val_c);
        let d = pool.spawn(val_d);

        pool.free(d);

        let ctx = pool.begin_multi_borrow();

        // Test empty.
        {
            assert_eq!(
                ctx.try_get(d).as_deref(),
                Err(MultiBorrowError::Empty(d)).as_ref()
            );
            assert_eq!(
                ctx.try_get_mut(d).as_deref_mut(),
                Err(MultiBorrowError::Empty(d)).as_mut()
            );
        }

        // Test immutable borrowing of the same element.
        {
            let ref_a_1 = ctx.try_get(a);
            let ref_a_2 = ctx.try_get(a);
            assert_eq!(ref_a_1.as_deref(), Ok(&val_a));
            assert_eq!(ref_a_2.as_deref(), Ok(&val_a));
        }

        // Test immutable borrowing of the same element with the following mutable borrowing.
        {
            let ref_a_1 = ctx.try_get(a);
            assert_eq!(unsafe { ref_a_1.as_ref().unwrap().ref_counter.get() }, 1);
            let ref_a_2 = ctx.try_get(a);
            assert_eq!(unsafe { ref_a_2.as_ref().unwrap().ref_counter.get() }, 2);

            assert_eq!(ref_a_1.as_deref(), Ok(&val_a));
            assert_eq!(ref_a_2.as_deref(), Ok(&val_a));
            assert_eq!(
                ctx.try_get_mut(a).as_deref(),
                Err(MultiBorrowError::ImmutablyBorrowed(a)).as_ref()
            );

            drop(ref_a_1);
            drop(ref_a_2);

            let mut mut_ref_a_1 = ctx.try_get_mut(a);
            assert_eq!(mut_ref_a_1.as_deref_mut(), Ok(&mut val_a));

            assert_eq!(
                unsafe { mut_ref_a_1.as_ref().unwrap().ref_counter.get() },
                -1
            );
        }

        // Test immutable and mutable borrowing.
        {
            // Borrow two immutable refs to the same element.
            let ref_a_1 = ctx.try_get(a);
            let ref_a_2 = ctx.try_get(a);
            assert_eq!(ref_a_1.as_deref(), Ok(&val_a));
            assert_eq!(ref_a_2.as_deref(), Ok(&val_a));

            // Borrow immutable ref to other element.
            let mut ref_b_1 = ctx.try_get_mut(b);
            let mut ref_b_2 = ctx.try_get_mut(b);
            assert_eq!(ref_b_1.as_deref_mut(), Ok(&mut val_b));
            assert_eq!(
                ref_b_2.as_deref_mut(),
                Err(MultiBorrowError::MutablyBorrowed(b)).as_mut()
            );

            let mut ref_c_1 = ctx.try_get_mut(c);
            let mut ref_c_2 = ctx.try_get_mut(c);
            assert_eq!(ref_c_1.as_deref_mut(), Ok(&mut val_c));
            assert_eq!(
                ref_c_2.as_deref_mut(),
                Err(MultiBorrowError::MutablyBorrowed(c)).as_mut()
            );
        }
    }
}


Path: ./src/pool/mod.rs

// Copyright (c) 2019-present Dmitry Stepanov and Fyrox Engine contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

//! A generational arena - a contiguous growable array type which allows removing
//! from the middle without shifting and therefore without invalidating other indices.
//!
//! Pool is a contiguous block of memory with fixed-size entries, each entry can be
//! either vacant or occupied. When you put an object into the pool you get a handle to
//! that object. You can use that handle later on to borrow a reference to an object.
//! A handle can point to some object or be invalid, this may look similar to raw
//! pointers, but there is two major differences:
//!
//! 1) We can check if a handle is valid before accessing the object it might point to.
//! 2) We can ensure the handle we're using is still valid for the object it points to
//! to make sure it hasn't been replaced with a different object on the same position.
//! Each handle stores a special field called generation which is shared across the entry
//! and the handle, so the handle is valid if these fields are the same on both the entry
//! and the handle. This protects from situations where you have a handle that has
//! a valid index of a record, but the payload in this record has been replaced.
//!
//! Contiguous memory block increases efficiency of memory operations - the CPU will
//! load portions of data into its cache piece by piece, it will be free from any
//! indirections that might cause cache invalidation. This is the so called cache
//! friendliness.

use std::cell::UnsafeCell;
use std::{
    any::{Any, TypeId},
    fmt::Debug,
    future::Future,
    marker::PhantomData,
    ops::{Index, IndexMut},
};

pub mod handle;
pub mod multiborrow;
pub mod payload;

pub use handle::*;
pub use multiborrow::*;
pub use payload::*;

const INVALID_GENERATION: u32 = 0;

/// Pool allows to create as many objects as you want in contiguous memory
/// block. It allows to create and delete objects much faster than if they'll
/// be allocated on heap. Also since objects stored in contiguous memory block
/// they can be effectively accessed because such memory layout is cache-friendly.
#[derive(Debug)]
pub struct Pool<T, P = Option<T>>
where
    T: Sized,
    P: PayloadContainer<Element = T>,
{
    records: Vec<PoolRecord<T, P>>,
    free_stack: Vec<u32>,
}

pub trait BorrowAs<Object, Container: PayloadContainer<Element = Object>> {
    type Target;
    fn borrow_as_ref(self, pool: &Pool<Object, Container>) -> Option<&Self::Target>;
    fn borrow_as_mut(self, pool: &mut Pool<Object, Container>) -> Option<&mut Self::Target>;
}

impl<Object, Container: PayloadContainer<Element = Object> + 'static> BorrowAs<Object, Container>
    for Handle<Object>
{
    type Target = Object;

    fn borrow_as_ref(self, pool: &Pool<Object, Container>) -> Option<&Object> {
        pool.try_borrow(self)
    }

    fn borrow_as_mut(self, pool: &mut Pool<Object, Container>) -> Option<&mut Object> {
        pool.try_borrow_mut(self)
    }
}

impl<T, P> PartialEq for Pool<T, P>
where
    T: PartialEq,
    P: PayloadContainer<Element = T> + PartialEq,
{
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.records == other.records
    }
}

// Zero - non-borrowed.
// Negative values - amount of mutable borrows, positive - amount of immutable borrows.
#[derive(Default, Debug)]
struct RefCounter(pub UnsafeCell<isize>);

unsafe impl Sync for RefCounter {}
unsafe impl Send for RefCounter {}

impl RefCounter {
    unsafe fn get(&self) -> isize {
        *self.0.get()
    }

    unsafe fn increment(&self) {
        *self.0.get() += 1;
    }

    unsafe fn decrement(&self) {
        *self.0.get() -= 1;
    }
}

#[derive(Debug)]
struct PoolRecord<T, P = Option<T>>
where
    T: Sized,
    P: PayloadContainer<Element = T>,
{
    ref_counter: RefCounter,
    // Generation number, used to keep info about lifetime. The handle is valid
    // only if record it points to is of the same generation as the pool record.
    // Notes: Zero is unknown generation used for None handles.
    generation: u32,
    // Actual payload.
    payload: Payload<P>,
}

impl<T, P> PartialEq for PoolRecord<T, P>
where
    T: PartialEq,
    P: PayloadContainer<Element = T> + PartialEq,
{
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.generation == other.generation && self.payload.get() == other.payload.get()
    }
}

impl<T, P> Default for PoolRecord<T, P>
where
    P: PayloadContainer<Element = T> + 'static,
{
    #[inline]
    fn default() -> Self {
        Self {
            ref_counter: Default::default(),
            generation: INVALID_GENERATION,
            payload: Payload::new_empty(),
        }
    }
}

impl<T> Clone for Handle<T> {
    #[inline]
    fn clone(&self) -> Handle<T> {
        *self
    }
}


impl<T, P> Default for Pool<T, P>
where
    T: 'static,
    P: PayloadContainer<Element = T> + 'static,
{
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug)]
pub struct Ticket<T> {
    index: u32,
    marker: PhantomData<T>,
}

impl<T> Drop for Ticket<T> {
    fn drop(&mut self) {
        panic!(
            "An object at index {} must be returned to a pool it was taken from! \
            Call Pool::forget_ticket if you don't need the object anymore.",
            self.index
        )
    }
}

impl<T: Clone> Clone for PoolRecord<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self {
            ref_counter: Default::default(),
            generation: self.generation,
            payload: self.payload.clone(),
        }
    }
}

impl<T: Clone> Clone for Pool<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self {
            records: self.records.clone(),
            free_stack: self.free_stack.clone(),
        }
    }
}

impl<T, P> Pool<T, P>
where
    P: PayloadContainer<Element = T> + 'static,
{
    #[inline]
    pub fn new() -> Self {
        Pool {
            records: Vec::new(),
            free_stack: Vec::new(),
        }
    }

    #[inline]
    pub fn with_capacity(capacity: u32) -> Self {
        let capacity = usize::try_from(capacity).expect("capacity overflowed usize");
        Pool {
            records: Vec::with_capacity(capacity),
            free_stack: Vec::new(),
        }
    }

    fn records_len(&self) -> u32 {
        u32::try_from(self.records.len()).expect("Number of records overflowed u32")
    }

    fn records_get(&self, index: u32) -> Option<&PoolRecord<T, P>> {
        let index = usize::try_from(index).expect("Index overflowed usize");
        self.records.get(index)
    }

    fn records_get_mut(&mut self, index: u32) -> Option<&mut PoolRecord<T, P>> {
        let index = usize::try_from(index).expect("Index overflowed usize");
        self.records.get_mut(index)
    }

    #[inline]
    pub fn typed_ref<Ref>(&self, handle: impl BorrowAs<T, P, Target = Ref>) -> Option<&Ref> {
        handle.borrow_as_ref(self)
    }

    #[inline]
    pub fn typed_mut<Ref>(
        &mut self,
        handle: impl BorrowAs<T, P, Target = Ref>,
    ) -> Option<&mut Ref> {
        handle.borrow_as_mut(self)
    }

    #[inline]
    #[must_use]
    pub fn spawn(&mut self, payload: T) -> Handle<T> {
        self.spawn_with(|_| payload)
    }

    /// Tries to put an object in the pool at given position. Returns `Err(payload)` if a corresponding
    /// entry is occupied.
    ///
    /// # Performance
    ///
    /// The method has O(n) complexity in worst case, where `n` - amount of free records in the pool.
    /// In typical uses cases `n` is very low. It should be noted that if a pool is filled entirely
    /// and you trying to put an object at the end of pool, the method will have O(1) complexity.
    ///
    /// # Panics
    ///
    /// Panics if the index is occupied or reserved (e.g. by [`take_reserve`]).
    ///
    /// [`take_reserve`]: Pool::take_reserve
    #[inline]
    pub fn spawn_at(&mut self, index: u32, payload: T) -> Result<Handle<T>, T> {
        self.spawn_at_internal(index, INVALID_GENERATION, payload)
    }

    /// Tries to put an object in the pool at given handle. Returns `Err(payload)` if a corresponding
    /// entry is occupied.
    ///
    /// # Performance
    ///
    /// The method has O(n) complexity in worst case, where `n` - amount of free records in the pool.
    /// In typical uses cases `n` is very low. It should be noted that if a pool is filled entirely
    /// and you trying to put an object at the end of pool, the method will have O(1) complexity.
    ///
    /// # Panics
    ///
    /// Panics if the index is occupied or reserved (e.g. by [`take_reserve`]).
    ///
    /// [`take_reserve`]: Pool::take_reserve
    #[inline]
    pub fn spawn_at_handle(&mut self, handle: Handle<T>, payload: T) -> Result<Handle<T>, T> {
        self.spawn_at_internal(handle.index, handle.generation, payload)
    }

    fn spawn_at_internal(
        &mut self,
        index: u32,
        desired_generation: u32,
        payload: T,
    ) -> Result<Handle<T>, T> {
        let index_usize = usize::try_from(index).expect("index overflowed usize");
        match self.records.get_mut(index_usize) {
            Some(record) => match record.payload.as_ref() {
                Some(_) => Err(payload),
                None => {
                    let position = self
                        .free_stack
                        .iter()
                        .rposition(|i| *i == index)
                        .expect("free_stack must contain the index of the empty record (most likely attempting to spawn at a reserved index)!");

                    self.free_stack.remove(position);

                    let generation = if desired_generation == INVALID_GENERATION {
                        record.generation + 1
                    } else {
                        desired_generation
                    };

                    record.generation = generation;
                    record.payload = Payload::new(payload);

                    Ok(Handle::new(index, generation))
                }
            },
            None => {
                // Spawn missing records to fill gaps.
                for i in self.records_len()..index {
                    self.records.push(PoolRecord {
                        ref_counter: Default::default(),
                        generation: 1,
                        payload: Payload::new_empty(),
                    });
                    self.free_stack.push(i);
                }

                let generation = if desired_generation == INVALID_GENERATION {
                    1
                } else {
                    desired_generation
                };

                self.records.push(PoolRecord {
                    ref_counter: Default::default(),
                    generation,
                    payload: Payload::new(payload),
                });

                Ok(Handle::new(index, generation))
            }
        }
    }

    #[inline]
    #[must_use]
    /// Construct a value with the handle it would be given.
    /// Note: Handle is _not_ valid until function has finished executing.
    pub fn spawn_with<F: FnOnce(Handle<T>) -> T>(&mut self, callback: F) -> Handle<T> {
        if let Some(free_index) = self.free_stack.pop() {
            let record = self
                .records_get_mut(free_index)
                .expect("free stack contained invalid index");

            if record.payload.is_some() {
                panic!(
                    "Attempt to spawn an object at pool record with payload! Record index is {free_index}"
                );
            }

            let generation = record.generation + 1;
            let handle = Handle {
                index: free_index,
                generation,
                type_marker: PhantomData,
            };

            let payload = callback(handle);

            record.generation = generation;
            record.payload.replace(payload);
            handle
        } else {
            // No free records, create new one
            let generation = 1;

            let handle = Handle {
                index: self.records.len() as u32,
                generation,
                type_marker: PhantomData,
            };

            let payload = callback(handle);

            let record = PoolRecord {
                ref_counter: Default::default(),
                generation,
                payload: Payload::new(payload),
            };

            self.records.push(record);

            handle
        }
    }

    #[inline]
    /// Asynchronously construct a value with the handle it would be given.
    /// Note: Handle is _not_ valid until function has finished executing.
    pub async fn spawn_with_async<F, Fut>(&mut self, callback: F) -> Handle<T>
    where
        F: FnOnce(Handle<T>) -> Fut,
        Fut: Future<Output = T>,
    {
        if let Some(free_index) = self.free_stack.pop() {
            let record = self
                .records_get_mut(free_index)
                .expect("free stack contained invalid index");

            if record.payload.is_some() {
                panic!(
                    "Attempt to spawn an object at pool record with payload! Record index is {free_index}"
                );
            }

            let generation = record.generation + 1;
            let handle = Handle {
                index: free_index,
                generation,
                type_marker: PhantomData,
            };

            let payload = callback(handle).await;

            record.generation = generation;
            record.payload.replace(payload);
            handle
        } else {
            // No free records, create new one
            let generation = 1;

            let handle = Handle {
                index: self.records.len() as u32,
                generation,
                type_marker: PhantomData,
            };

            let payload = callback(handle).await;

            let record = PoolRecord {
                generation,
                ref_counter: Default::default(),
                payload: Payload::new(payload),
            };

            self.records.push(record);

            handle
        }
    }

    /// Generates a set of handles that could be used to spawn a set of objects. This method does not
    /// modify the pool and the generated handles could be used together with [`Self::spawn_at_handle`]
    /// method.
    #[inline]
    pub fn generate_free_handles(&self, amount: usize) -> Vec<Handle<T>> {
        let mut free_handles = Vec::with_capacity(amount);
        free_handles.extend(
            self.free_stack
                .iter()
                .rev()
                .take(amount)
                .map(|i| Handle::new(*i, self.records[*i as usize].generation + 1)),
        );
        if free_handles.len() < amount {
            let remainder = amount - free_handles.len();
            free_handles.extend(
                (self.records.len()..self.records.len() + remainder)
                    .map(|i| Handle::new(i as u32, 1)),
            );
        }
        free_handles
    }

    /// Borrows shared reference to an object by its handle.
    ///
    /// # Panics
    ///
    /// Panics if handle is out of bounds or generation of handle does not match with
    /// generation of pool record at handle index (in other words it means that object
    /// at handle's index is different than the object was there before).
    #[inline]
    #[must_use]
    pub fn borrow(&self, handle: Handle<T>) -> &T {
        if let Some(record) = self.records_get(handle.index) {
            if record.generation == handle.generation {
                if let Some(payload) = record.payload.as_ref() {
                    payload
                } else {
                    panic!("Attempt to borrow destroyed object at {handle:?} handle.");
                }
            } else {
                panic!(
                    "Attempt to use dangling handle {:?}. Record has generation {}!",
                    handle, record.generation
                );
            }
        } else {
            panic!(
                "Attempt to borrow object using out-of-bounds handle {:?}! Record count is {}",
                handle,
                self.records.len()
            );
        }
    }

    /// Borrows mutable reference to an object by its handle.
    ///
    /// # Panics
    ///
    /// Panics if handle is out of bounds or generation of handle does not match with
    /// generation of pool record at handle index (in other words it means that object
    /// at handle's index is different than the object was there before).
    ///
    /// # Example
    ///
    /// ```
    /// use fyrox_core::pool::Pool;
    /// let mut pool = Pool::<u32>::new();
    /// let a = pool.spawn(1);
    /// let a = pool.borrow_mut(a);
    /// *a = 11;
    /// ```
    #[inline]
    #[must_use]
    pub fn borrow_mut(&mut self, handle: Handle<T>) -> &mut T {
        let record_count = self.records.len();
        if let Some(record) = self.records_get_mut(handle.index) {
            if record.generation == handle.generation {
                if let Some(payload) = record.payload.as_mut() {
                    payload
                } else {
                    panic!("Attempt to borrow destroyed object at {handle:?} handle.");
                }
            } else {
                panic!("Attempt to borrow object using dangling handle {:?}. Record has {} generation!", handle, record.generation);
            }
        } else {
            panic!(
                "Attempt to borrow object using out-of-bounds handle {handle:?}! Record count is {record_count}"
            );
        }
    }

    /// Borrows shared reference to an object by its handle.
    ///
    /// Returns None if handle is out of bounds or generation of handle does not match with
    /// generation of pool record at handle index (in other words it means that object
    /// at handle's index is different than the object was there before).
    #[inline]
    #[must_use]
    pub fn try_borrow(&self, handle: Handle<T>) -> Option<&T> {
        self.records_get(handle.index).and_then(|r| {
            if r.generation == handle.generation {
                r.payload.as_ref()
            } else {
                None
            }
        })
    }

    /// Borrows mutable reference to an object by its handle.
    ///
    /// Returns None if handle is out of bounds or generation of handle does not match with
    /// generation of pool record at handle index (in other words it means that object
    /// at handle's index is different than the object was there before).
    #[inline]
    #[must_use]
    pub fn try_borrow_mut(&mut self, handle: Handle<T>) -> Option<&mut T> {
        self.records_get_mut(handle.index).and_then(|r| {
            if r.generation == handle.generation {
                r.payload.as_mut()
            } else {
                None
            }
        })
    }

    /// Borrows mutable references of objects at the same time. This method will succeed only
    /// if handles are unique (not equal). Borrowing multiple mutable references at the same
    /// time is useful in case if you need to mutate some objects at the same time.
    ///
    /// # Panics
    ///
    /// See [`borrow_mut`](Self::borrow_mut).
    ///
    /// # Example
    ///
    /// ```
    /// use fyrox_core::pool::Pool;
    /// let mut pool = Pool::<u32>::new();
    /// let a = pool.spawn(1);
    /// let b = pool.spawn(2);
    /// let (a, b) = pool.borrow_two_mut((a, b));
    /// *a = 11;
    /// *b = 22;
    /// ```
    #[inline]
    #[must_use = "Handle set must not be ignored"]
    pub fn borrow_two_mut(&mut self, handles: (Handle<T>, Handle<T>)) -> (&mut T, &mut T) {
        // Prevent giving two mutable references to same record.
        assert_ne!(handles.0.index, handles.1.index);
        unsafe {
            let this = self as *mut Self;
            ((*this).borrow_mut(handles.0), (*this).borrow_mut(handles.1))
        }
    }

    /// Borrows mutable references of objects at the same time. This method will succeed only
    /// if handles are unique (not equal). Borrowing multiple mutable references at the same
    /// time is useful in case if you need to mutate some objects at the same time.
    ///
    /// # Panics
    ///
    /// See [`borrow_mut`](Self::borrow_mut).
    ///
    /// # Example
    ///
    /// ```
    /// use fyrox_core::pool::Pool;
    /// let mut pool = Pool::<u32>::new();
    /// let a = pool.spawn(1);
    /// let b = pool.spawn(2);
    /// let c = pool.spawn(3);
    /// let (a, b, c) = pool.borrow_three_mut((a, b, c));
    /// *a = 11;
    /// *b = 22;
    /// *c = 33;
    /// ```
    #[inline]
    #[must_use = "Handle set must not be ignored"]
    pub fn borrow_three_mut(
        &mut self,
        handles: (Handle<T>, Handle<T>, Handle<T>),
    ) -> (&mut T, &mut T, &mut T) {
        // Prevent giving mutable references to same record.
        assert_ne!(handles.0.index, handles.1.index);
        assert_ne!(handles.0.index, handles.2.index);
        assert_ne!(handles.1.index, handles.2.index);
        unsafe {
            let this = self as *mut Self;
            (
                (*this).borrow_mut(handles.0),
                (*this).borrow_mut(handles.1),
                (*this).borrow_mut(handles.2),
            )
        }
    }

    /// Borrows mutable references of objects at the same time. This method will succeed only
    /// if handles are unique (not equal). Borrowing multiple mutable references at the same
    /// time is useful in case if you need to mutate some objects at the same time.
    ///
    /// # Panics
    ///
    /// See [`borrow_mut`](Self::borrow_mut).
    ///
    /// # Example
    ///
    /// ```
    /// use fyrox_core::pool::Pool;
    /// let mut pool = Pool::<u32>::new();
    /// let a = pool.spawn(1);
    /// let b = pool.spawn(2);
    /// let c = pool.spawn(3);
    /// let d = pool.spawn(4);
    /// let (a, b, c, d) = pool.borrow_four_mut((a, b, c, d));
    /// *a = 11;
    /// *b = 22;
    /// *c = 33;
    /// *d = 44;
    /// ```
    #[inline]
    #[must_use = "Handle set must not be ignored"]
    pub fn borrow_four_mut(
        &mut self,
        handles: (Handle<T>, Handle<T>, Handle<T>, Handle<T>),
    ) -> (&mut T, &mut T, &mut T, &mut T) {
        // Prevent giving mutable references to same record.
        // This is kinda clunky since const generics are not stabilized yet.
        assert_ne!(handles.0.index, handles.1.index);
        assert_ne!(handles.0.index, handles.2.index);
        assert_ne!(handles.0.index, handles.3.index);
        assert_ne!(handles.1.index, handles.2.index);
        assert_ne!(handles.1.index, handles.3.index);
        assert_ne!(handles.2.index, handles.3.index);
        unsafe {
            let this = self as *mut Self;
            (
                (*this).borrow_mut(handles.0),
                (*this).borrow_mut(handles.1),
                (*this).borrow_mut(handles.2),
                (*this).borrow_mut(handles.3),
            )
        }
    }

    /// Tries to borrow two objects when a handle to the second object stored in the first object.
    #[inline]
    pub fn try_borrow_dependant_mut<F>(
        &mut self,
        handle: Handle<T>,
        func: F,
    ) -> (Option<&mut T>, Option<&mut T>)
    where
        F: FnOnce(&T) -> Handle<T>,
    {
        let this = unsafe { &mut *(self as *mut Pool<T, P>) };
        let first = self.try_borrow_mut(handle);
        if let Some(first_object) = first.as_ref() {
            let second_handle = func(first_object);
            if second_handle != handle {
                return (first, this.try_borrow_mut(second_handle));
            }
        }

        (first, None)
    }

    /// Moves object out of the pool using the given handle. All handles to the object will become invalid.
    ///
    /// # Panics
    ///
    /// Panics if the given handle is invalid.
    #[inline]
    pub fn free(&mut self, handle: Handle<T>) -> T {
        let index = usize::try_from(handle.index).expect("index overflowed usize");
        if let Some(record) = self.records.get_mut(index) {
            if record.generation == handle.generation {
                // Remember this index as free
                self.free_stack.push(handle.index);
                // Return current payload.
                if let Some(payload) = record.payload.take() {
                    payload
                } else {
                    panic!("Attempt to double free object at handle {handle:?}!");
                }
            } else {
                panic!(
                    "Attempt to free object using dangling handle {:?}! Record generation is {}",
                    handle, record.generation
                );
            }
        } else {
            panic!("Attempt to free destroyed object using out-of-bounds handle {:?}! Record count is {}", handle, self.records.len());
        }
    }

    /// Tries to move object out of the pool using the given handle. Returns None if given handle
    /// is invalid. After object is moved out if the pool, all handles to the object will become
    /// invalid.
    #[inline]
    pub fn try_free(&mut self, handle: Handle<T>) -> Option<T> {
        let index = usize::try_from(handle.index).expect("index overflowed usize");
        self.records.get_mut(index).and_then(|record| {
            if record.generation == handle.generation {
                if let Some(payload) = record.payload.take() {
                    self.free_stack.push(handle.index);
                    Some(payload)
                } else {
                    None
                }
            } else {
                None
            }
        })
    }

    /// Moves an object out of the pool using the given handle with a promise that the object will be returned back.
    /// Returns pair (ticket, value). The ticket must be used to put the value back!
    ///
    /// # Motivation
    ///
    /// This method is useful when you need to take temporary ownership of an object, do something
    /// with it and then put it back while preserving all handles to it and being able to put new objects into
    /// the pool without overriding the payload at its handle.
    ///
    /// # Notes
    ///
    /// All handles to the object will be temporarily invalid until the object is returned to the pool! The pool record will
    /// be reserved for a further [`put_back`] call, which means if you lose the ticket you will have an empty
    /// "unusable" pool record forever.
    ///
    /// # Panics
    ///
    /// Panics if the given handle is invalid.
    ///
    /// [`put_back`]: Pool::put_back
    #[inline]
    pub fn take_reserve(&mut self, handle: Handle<T>) -> (Ticket<T>, T) {
        if let Some(record) = self.records_get_mut(handle.index) {
            if record.generation == handle.generation {
                if let Some(payload) = record.payload.take() {
                    let ticket = Ticket {
                        index: handle.index,
                        marker: PhantomData,
                    };
                    (ticket, payload)
                } else {
                    panic!("Attempt to take already taken object at handle {handle:?}!");
                }
            } else {
                panic!(
                    "Attempt to take object using dangling handle {:?}! Record generation is {}",
                    handle, record.generation
                );
            }
        } else {
            panic!("Attempt to take destroyed object using out-of-bounds handle {:?}! Record count is {}", handle, self.records.len());
        }
    }

    /// Does the same as [`take_reserve`] but returns an option, instead of panicking.
    ///
    /// [`take_reserve`]: Pool::take_reserve
    #[inline]
    pub fn try_take_reserve(&mut self, handle: Handle<T>) -> Option<(Ticket<T>, T)> {
        if let Some(record) = self.records_get_mut(handle.index) {
            if record.generation == handle.generation {
                if let Some(payload) = record.payload.take() {
                    let ticket = Ticket {
                        index: handle.index,
                        marker: PhantomData,
                    };
                    Some((ticket, payload))
                } else {
                    None
                }
            } else {
                None
            }
        } else {
            None
        }
    }

    /// Returns the value back into the pool using the given ticket. See [`take_reserve`] for more
    /// information.
    ///
    /// [`take_reserve`]: Pool::take_reserve
    #[inline]
    pub fn put_back(&mut self, ticket: Ticket<T>, value: T) -> Handle<T> {
        let record = self
            .records_get_mut(ticket.index)
            .expect("Ticket index was invalid");
        let old = record.payload.replace(value);
        assert!(old.is_none());
        let handle = Handle::new(ticket.index, record.generation);
        std::mem::forget(ticket);
        handle
    }

    /// Forgets that value at ticket was reserved and makes it usable again.
    /// Useful when you don't need to put value back by ticket, but just make
    /// pool record usable again.
    #[inline]
    pub fn forget_ticket(&mut self, ticket: Ticket<T>) {
        self.free_stack.push(ticket.index);
        std::mem::forget(ticket);
    }

    /// Returns total capacity of pool. Capacity has nothing about real amount of objects in pool!
    #[inline]
    #[must_use]
    pub fn get_capacity(&self) -> u32 {
        u32::try_from(self.records.len()).expect("records.len() overflowed u32")
    }

    /// Destroys all objects in pool. All handles to objects will become invalid.
    ///
    /// # Remarks
    ///
    /// Use this method cautiously if objects in pool have cross "references" (handles)
    /// to each other. This method will make all produced handles invalid and any further
    /// calls for [`borrow`](Self::borrow) or [`borrow_mut`](Self::borrow_mut) will raise panic.
    #[inline]
    pub fn clear(&mut self) {
        self.records.clear();
        self.free_stack.clear();
    }

    #[inline]
    #[must_use]
    pub fn at_mut(&mut self, n: u32) -> Option<&mut T> {
        self.records_get_mut(n).and_then(|rec| rec.payload.as_mut())
    }

    #[inline]
    #[must_use]
    pub fn at(&self, n: u32) -> Option<&T> {
        self.records_get(n)
            .and_then(|rec| rec.payload.get().as_ref())
    }

    #[inline]
    #[must_use]
    pub fn handle_from_index(&self, n: u32) -> Handle<T> {
        if let Some(record) = self.records_get(n) {
            if record.generation != INVALID_GENERATION {
                return Handle::new(n, record.generation);
            }
        }
        Handle::NONE
    }

    /// Returns the exact number of "alive" objects in the pool.
    ///
    /// Records that have been reserved (e.g. by [`take_reserve`]) are *not* counted.
    ///
    /// It iterates through the entire pool to count the live objects so the complexity is `O(n)`.
    ///
    /// See also [`total_count`].
    ///
    /// # Example
    ///
    /// ```
    /// use fyrox_core::pool::Pool;
    /// let mut pool = Pool::<u32>::new();
    /// pool.spawn(123);
    /// pool.spawn(321);
    /// assert_eq!(pool.alive_count(), 2);
    /// ```
    ///
    /// [`take_reserve`]: Pool::take_reserve
    /// [`total_count`]: Pool::total_count
    #[inline]
    #[must_use]
    pub fn alive_count(&self) -> u32 {
        let cnt = self.iter().count();
        u32::try_from(cnt).expect("alive_count overflowed u32")
    }

    /// Returns the number of allocated objects in the pool.
    ///
    /// It also counts records that have been reserved (e.g. by [`take_reserve`]).
    ///
    /// This method is `O(1)`.
    ///
    /// See also [`alive_count`].
    ///
    /// [`take_reserve`]: Pool::take_reserve
    /// [`alive_count`]: Pool::alive_count
    #[inline]
    pub fn total_count(&self) -> u32 {
        let free = u32::try_from(self.free_stack.len()).expect("free stack length overflowed u32");
        self.records_len() - free
    }

    #[inline]
    pub fn replace(&mut self, handle: Handle<T>, payload: T) -> Option<T> {
        let index_usize = usize::try_from(handle.index).expect("index overflowed usize");
        if let Some(record) = self.records.get_mut(index_usize) {
            if record.generation == handle.generation {
                self.free_stack.retain(|i| *i != handle.index);

                record.payload.replace(payload)
            } else {
                panic!("Attempt to replace object in pool using dangling handle! Handle is {:?}, but pool record has {} generation", handle, record.generation);
            }
        } else {
            None
        }
    }

    /// Returns a reference to the first element in the pool (if any).
    pub fn first_ref(&self) -> Option<&T> {
        self.iter().next()
    }

    /// Returns a reference to the first element in the pool (if any).
    pub fn first_mut(&mut self) -> Option<&mut T> {
        self.iter_mut().next()
    }

    /// Checks if given handle "points" to some object.
    ///
    /// # Example
    ///
    /// ```
    /// use fyrox_core::pool::Pool;
    /// let mut pool = Pool::<u32>::new();
    /// let handle = pool.spawn(123);
    /// assert_eq!(pool.is_valid_handle(handle), true)
    /// ```
    #[inline]
    pub fn is_valid_handle(&self, handle: Handle<T>) -> bool {
        if let Some(record) = self.records_get(handle.index) {
            record.payload.is_some() && record.generation == handle.generation
        } else {
            false
        }
    }

    /// Creates new pool iterator that iterates over filled records in pool.
    ///
    /// # Example
    ///
    /// ```
    /// use fyrox_core::pool::Pool;
    /// let mut pool = Pool::<u32>::new();
    /// pool.spawn(123);
    /// pool.spawn(321);
    /// let mut iter = pool.iter();
    /// assert_eq!(*iter.next().unwrap(), 123);
    /// assert_eq!(*iter.next().unwrap(), 321);
    /// ```
    #[must_use]
    #[inline]
    pub fn iter(&self) -> PoolIterator<T, P> {
        unsafe {
            PoolIterator {
                ptr: self.records.as_ptr(),
                end: self.records.as_ptr().add(self.records.len()),
                marker: PhantomData,
            }
        }
    }

    /// Creates new pair iterator that iterates over filled records using pair (handle, payload)
    /// Can be useful when there is a need to iterate over pool records and know a handle of
    /// that record.
    #[inline]
    pub fn pair_iter(&self) -> PoolPairIterator<T, P> {
        PoolPairIterator {
            pool: self,
            current: 0,
        }
    }

    /// Creates new pool iterator that iterates over filled records in pool allowing
    /// to modify record payload.
    ///
    /// # Example
    ///
    /// ```
    /// use fyrox_core::pool::Pool;
    /// let mut pool = Pool::<u32>::new();
    /// pool.spawn(123);
    /// pool.spawn(321);
    /// let mut iter = pool.iter_mut();
    /// assert_eq!(*iter.next().unwrap(), 123);
    /// assert_eq!(*iter.next().unwrap(), 321);
    /// ```
    #[must_use]
    #[inline]
    pub fn iter_mut(&mut self) -> PoolIteratorMut<T, P> {
        unsafe {
            PoolIteratorMut {
                ptr: self.records.as_mut_ptr(),
                end: self.records.as_mut_ptr().add(self.records.len()),
                marker: PhantomData,
            }
        }
    }

    /// Creates new pair iterator that iterates over filled records using pair (handle, payload)
    /// Can be useful when there is a need to iterate over pool records and know a handle of
    /// that record.
    #[inline]
    pub fn pair_iter_mut(&mut self) -> PoolPairIteratorMut<T, P> {
        unsafe {
            PoolPairIteratorMut {
                current: 0,
                ptr: self.records.as_mut_ptr(),
                end: self.records.as_mut_ptr().add(self.records.len()),
                marker: PhantomData,
            }
        }
    }

    /// Retains pool records selected by `pred`. Useful when you need to remove all pool records
    /// by some criteria.
    #[inline]
    pub fn retain<F>(&mut self, mut pred: F)
    where
        F: FnMut(&T) -> bool,
    {
        for (i, record) in self.records.iter_mut().enumerate() {
            if record.generation == INVALID_GENERATION {
                continue;
            }

            let retain = if let Some(payload) = record.payload.as_ref() {
                pred(payload)
            } else {
                continue;
            };

            if !retain {
                self.free_stack.push(i as u32);
                record.payload.take(); // and Drop
            }
        }
    }

    /// Begins multi-borrow that allows you to borrow as many (`N`) **unique** references to the pool
    /// elements as you need. See [`MultiBorrowContext::try_get`] for more info.
    #[inline]
    pub fn begin_multi_borrow(&mut self) -> MultiBorrowContext<T, P> {
        MultiBorrowContext::new(self)
    }

    /// Removes all elements from the pool.
    #[inline]
    pub fn drain(&mut self) -> impl Iterator<Item = T> + '_ {
        self.free_stack.clear();
        self.records.drain(..).filter_map(|mut r| r.payload.take())
    }

    fn end(&self) -> *const PoolRecord<T, P> {
        unsafe { self.records.as_ptr().add(self.records.len()) }
    }

    fn begin(&self) -> *const PoolRecord<T, P> {
        self.records.as_ptr()
    }

    #[inline]
    pub fn handle_of(&self, ptr: &T) -> Handle<T> {
        let begin = self.begin() as usize;
        let end = self.end() as usize;
        let val = ptr as *const T as usize;
        if val >= begin && val < end {
            let record_size = std::mem::size_of::<PoolRecord<T>>();
            let record_location = (val - std::mem::offset_of!(PoolRecord<T>, payload)) - begin;
            if record_location % record_size == 0 {
                let index = record_location / record_size;
                let index = u32::try_from(index).expect("Index overflowed u32");
                return self.handle_from_index(index);
            }
        }
        Handle::NONE
    }
}

impl<T> FromIterator<T> for Pool<T>
where
    T: 'static,
{
    #[inline]
    fn from_iter<C: IntoIterator<Item = T>>(iter: C) -> Self {
        let iter = iter.into_iter();
        let (lower_bound, upper_bound) = iter.size_hint();
        let lower_bound = u32::try_from(lower_bound).expect("lower_bound overflowed u32");
        let upper_bound =
            upper_bound.map(|b| u32::try_from(b).expect("upper_bound overflowed u32"));
        let mut pool = Self::with_capacity(upper_bound.unwrap_or(lower_bound));
        for v in iter {
            let _ = pool.spawn(v);
        }
        pool
    }
}

impl<Object, Container, Borrow, Ref> Index<Borrow> for Pool<Object, Container>
where
    Object: 'static,
    Container: PayloadContainer<Element = Object> + 'static,
    Borrow: BorrowAs<Object, Container, Target = Ref>,
{
    type Output = Ref;

    #[inline]
    fn index(&self, index: Borrow) -> &Self::Output {
        self.typed_ref(index).expect("The handle must be valid!")
    }
}

impl<Object, Container, Borrow, Ref> IndexMut<Borrow> for Pool<Object, Container>
where
    Object: 'static,
    Container: PayloadContainer<Element = Object> + 'static,
    Borrow: BorrowAs<Object, Container, Target = Ref>,
{
    #[inline]
    fn index_mut(&mut self, index: Borrow) -> &mut Self::Output {
        self.typed_mut(index).expect("The handle must be valid!")
    }
}

impl<'a, T, P> IntoIterator for &'a Pool<T, P>
where
    P: PayloadContainer<Element = T> + 'static,
{
    type Item = &'a T;
    type IntoIter = PoolIterator<'a, T, P>;

    #[inline]
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}

impl<'a, T, P> IntoIterator for &'a mut Pool<T, P>
where
    P: PayloadContainer<Element = T> + 'static,
{
    type Item = &'a mut T;
    type IntoIter = PoolIteratorMut<'a, T, P>;

    #[inline]
    fn into_iter(self) -> Self::IntoIter {
        self.iter_mut()
    }
}

pub struct PoolIterator<'a, T, P>
where
    P: PayloadContainer<Element = T>,
{
    ptr: *const PoolRecord<T, P>,
    end: *const PoolRecord<T, P>,
    marker: PhantomData<&'a T>,
}

impl<'a, T, P> Iterator for PoolIterator<'a, T, P>
where
    P: PayloadContainer<Element = T> + 'static,
{
    type Item = &'a T;

    #[inline]
    fn next(&mut self) -> Option<Self::Item> {
        unsafe {
            while self.ptr != self.end {
                let current = &*self.ptr;
                if let Some(payload) = current.payload.as_ref() {
                    self.ptr = self.ptr.offset(1);
                    return Some(payload);
                }
                self.ptr = self.ptr.offset(1);
            }

            None
        }
    }
}

pub struct PoolPairIterator<'a, T, P: PayloadContainer<Element = T>> {
    pool: &'a Pool<T, P>,
    current: usize,
}

impl<'a, T, P> Iterator for PoolPairIterator<'a, T, P>
where
    P: PayloadContainer<Element = T>,
{
    type Item = (Handle<T>, &'a T);

    #[inline]
    fn next(&mut self) -> Option<Self::Item> {
        loop {
            match self.pool.records.get(self.current) {
                Some(record) => {
                    if let Some(payload) = record.payload.as_ref() {
                        let handle = Handle::new(self.current as u32, record.generation);
                        self.current += 1;
                        return Some((handle, payload));
                    }
                    self.current += 1;
                }
                None => return None,
            }
        }
    }
}

pub struct PoolIteratorMut<'a, T, P>
where
    P: PayloadContainer<Element = T>,
{
    ptr: *mut PoolRecord<T, P>,
    end: *mut PoolRecord<T, P>,
    marker: PhantomData<&'a mut T>,
}

impl<'a, T, P> Iterator for PoolIteratorMut<'a, T, P>
where
    P: PayloadContainer<Element = T> + 'static,
{
    type Item = &'a mut T;

    #[inline]
    fn next(&mut self) -> Option<Self::Item> {
        unsafe {
            while self.ptr != self.end {
                let current = &mut *self.ptr;
                if let Some(payload) = current.payload.as_mut() {
                    self.ptr = self.ptr.offset(1);
                    return Some(payload);
                }
                self.ptr = self.ptr.offset(1);
            }

            None
        }
    }
}

pub struct PoolPairIteratorMut<'a, T, P>
where
    P: PayloadContainer<Element = T>,
{
    ptr: *mut PoolRecord<T, P>,
    end: *mut PoolRecord<T, P>,
    marker: PhantomData<&'a mut T>,
    current: usize,
}

impl<'a, T, P> Iterator for PoolPairIteratorMut<'a, T, P>
where
    P: PayloadContainer<Element = T> + 'static,
{
    type Item = (Handle<T>, &'a mut T);

    #[inline]
    fn next(&mut self) -> Option<Self::Item> {
        unsafe {
            while self.ptr != self.end {
                let current = &mut *self.ptr;
                if let Some(payload) = current.payload.as_mut() {
                    let handle = Handle::new(self.current as u32, current.generation);
                    self.ptr = self.ptr.offset(1);
                    self.current += 1;
                    return Some((handle, payload));
                }
                self.ptr = self.ptr.offset(1);
                self.current += 1;
            }

            None
        }
    }
}

#[cfg(test)]
mod test {
    use crate::{
        pool::{AtomicHandle, Handle, Pool, PoolRecord, INVALID_GENERATION},
    };

    #[test]
    fn pool_sanity_tests() {
        let mut pool: Pool<String> = Pool::new();
        let foobar_handle = pool.spawn(String::from("Foobar"));
        assert_eq!(foobar_handle.index, 0);
        assert_ne!(foobar_handle.generation, INVALID_GENERATION);
        let foobar_handle_copy = foobar_handle;
        assert_eq!(foobar_handle.index, foobar_handle_copy.index);
        assert_eq!(foobar_handle.generation, foobar_handle_copy.generation);
        let baz_handle = pool.spawn(String::from("Baz"));
        assert_eq!(pool.borrow(foobar_handle), "Foobar");
        assert_eq!(pool.borrow(baz_handle), "Baz");
        pool.free(foobar_handle);
        assert!(!pool.is_valid_handle(foobar_handle_copy));
        assert!(pool.is_valid_handle(baz_handle));
        let at_foobar_index = pool.spawn(String::from("AtFoobarIndex"));
        assert_eq!(at_foobar_index.index, 0);
        assert_ne!(at_foobar_index.generation, INVALID_GENERATION);
        assert_eq!(pool.borrow(at_foobar_index), "AtFoobarIndex");
        let bar_handle = pool.spawn_with(|_handle| String::from("Bar"));
        assert_ne!(bar_handle.index, 0);
        assert_ne!(bar_handle.generation, INVALID_GENERATION);
        assert_eq!(pool.borrow(bar_handle), "Bar");
    }

    #[test]
    fn pool_iterator_mut_test() {
        let mut pool: Pool<String> = Pool::new();
        let foobar = pool.spawn("Foobar".to_string());
        let d = pool.spawn("Foo".to_string());
        pool.free(d);
        let baz = pool.spawn("Baz".to_string());
        for s in pool.iter() {
            println!("{s}");
        }
        for s in pool.iter_mut() {
            println!("{s}");
        }
        for s in &pool {
            println!("{s}");
        }
        for s in &mut pool {
            println!("{s}");
        }
        pool.free(foobar);
        pool.free(baz);
    }

    #[test]
    fn handle_of() {
        #[allow(dead_code)]
        struct Value {
            data: String,
        }

        let mut pool = Pool::<Value>::new();
        let foobar = pool.spawn(Value {
            data: "Foobar".to_string(),
        });
        let bar = pool.spawn(Value {
            data: "Bar".to_string(),
        });
        let baz = pool.spawn(Value {
            data: "Baz".to_string(),
        });
        assert_eq!(pool.handle_of(pool.borrow(foobar)), foobar);
        assert_eq!(pool.handle_of(pool.borrow(bar)), bar);
        assert_eq!(pool.handle_of(pool.borrow(baz)), baz);
    }

    #[derive(Debug, Eq, PartialEq)]
    struct Payload;

    #[test]
    fn pool_test_spawn_at() {
        let mut pool = Pool::<Payload>::new();

        assert_eq!(pool.spawn_at(2, Payload), Ok(Handle::new(2, 1)));
        assert_eq!(pool.spawn_at(2, Payload), Err(Payload));
        assert_eq!(pool.records[0].payload.as_ref(), None);
        assert_eq!(pool.records[1].payload.as_ref(), None);
        assert_ne!(pool.records[2].payload.as_ref(), None);

        assert_eq!(pool.spawn_at(2, Payload), Err(Payload));

        pool.free(Handle::new(2, 1));

        assert_eq!(pool.spawn_at(2, Payload), Ok(Handle::new(2, 2)));

        assert_eq!(pool.spawn(Payload), Handle::new(1, 2));
        assert_eq!(pool.spawn(Payload), Handle::new(0, 2));
    }

    #[test]
    fn pool_test_try_free() {
        let mut pool = Pool::<Payload>::new();

        assert_eq!(pool.try_free(Handle::NONE), None);
        assert_eq!(pool.free_stack.len(), 0);

        let handle = pool.spawn(Payload);
        assert_eq!(pool.try_free(handle), Some(Payload));
        assert_eq!(pool.free_stack.len(), 1);
        assert_eq!(pool.try_free(handle), None);
        assert_eq!(pool.free_stack.len(), 1);
    }

    #[test]
    fn default_for_pool() {
        assert_eq!(Pool::default(), Pool::<u32>::new());
    }

    #[test]
    fn pool_with_capacity() {
        let p = Pool::<u32>::with_capacity(1);
        assert_eq!(p.records, Vec::with_capacity(1));
        assert_eq!(p.free_stack, Vec::new())
    }

    #[test]
    fn pool_try_borrow() {
        let mut pool = Pool::<Payload>::new();
        let a = pool.spawn(Payload);
        let b = Handle::<Payload>::default();

        assert_eq!(pool.try_borrow(a), Some(&Payload));
        assert_eq!(pool.try_borrow(b), None);
    }

    #[test]
    fn pool_borrow_two_mut() {
        let mut pool = Pool::<u32>::new();
        let a = pool.spawn(1);
        let b = pool.spawn(2);
        let (a, b) = pool.borrow_two_mut((a, b));

        assert_eq!(a, &mut 1);
        assert_eq!(b, &mut 2);
    }

    #[test]
    fn pool_borrow_three_mut() {
        let mut pool = Pool::<u32>::new();
        let a = pool.spawn(1);
        let b = pool.spawn(2);
        let c = pool.spawn(3);
        let (a, b, c) = pool.borrow_three_mut((a, b, c));

        assert_eq!(a, &mut 1);
        assert_eq!(b, &mut 2);
        assert_eq!(c, &mut 3);
    }

    #[test]
    fn pool_borrow_four_mut() {
        let mut pool = Pool::<u32>::new();
        let a = pool.spawn(1);
        let b = pool.spawn(2);
        let c = pool.spawn(3);
        let d = pool.spawn(4);
        let (a, b, c, d) = pool.borrow_four_mut((a, b, c, d));

        assert_eq!(a, &mut 1);
        assert_eq!(b, &mut 2);
        assert_eq!(c, &mut 3);
        assert_eq!(d, &mut 4);
    }

    #[test]
    fn pool_try_borrow_dependant_mut() {
        let mut pool = Pool::<u32>::new();
        let a = pool.spawn(42);
        let b = pool.spawn(5);

        assert_eq!(
            pool.try_borrow_dependant_mut(a, |_| b),
            (Some(&mut 42), Some(&mut 5))
        );

        assert_eq!(
            pool.try_borrow_dependant_mut(a, |_| a),
            (Some(&mut 42), None)
        );
    }

    #[test]
    fn pool_try_take_reserve() {
        let mut pool = Pool::<u32>::new();

        let a = Handle::<u32>::default();
        assert!(pool.try_take_reserve(a).is_none());

        let b = pool.spawn(42);

        let (ticket, payload) = pool.try_take_reserve(b).unwrap();
        assert_eq!(ticket.index, 0);
        assert_eq!(payload, 42);

        assert!(pool.try_take_reserve(a).is_none());
        assert!(pool.try_take_reserve(b).is_none());

        pool.forget_ticket(ticket);
    }

    #[test]
    fn pool_put_back() {
        let mut pool = Pool::<u32>::new();
        let a = pool.spawn(42);
        let (ticket, value) = pool.take_reserve(a);
        let b = pool.put_back(ticket, value);

        assert_eq!(a, b);
    }

    #[test]
    fn pool_forget_ticket() {
        let mut pool = Pool::<u32>::new();
        let a = pool.spawn(42);
        let (ticket, _) = pool.take_reserve(a);

        pool.forget_ticket(ticket);

        let b = pool.spawn(42);

        assert_eq!(a.index, b.index);
        assert_ne!(a.generation, b.generation);
    }

    #[test]
    fn pool_get_capacity() {
        let mut pool = Pool::<u32>::new();
        let _ = pool.spawn(42);
        let _ = pool.spawn(5);

        assert_eq!(pool.get_capacity(), 2);
    }

    #[test]
    fn pool_clear() {
        let mut pool = Pool::<u32>::new();
        let _ = pool.spawn(42);

        assert!(!pool.records.is_empty());

        pool.clear();

        assert!(pool.records.is_empty());
        assert!(pool.free_stack.is_empty());
    }

    #[test]
    fn pool_at_mut() {
        let mut pool = Pool::<u32>::new();
        let _ = pool.spawn(42);

        assert_eq!(pool.at_mut(0), Some(&mut 42));
        assert_eq!(pool.at_mut(1), None);
    }

    #[test]
    fn pool_at() {
        let mut pool = Pool::<u32>::new();
        let _ = pool.spawn(42);

        assert_eq!(pool.at(0), Some(&42));
        assert_eq!(pool.at(1), None);
    }

    #[test]
    fn pool_handle_from_index() {
        let mut pool = Pool::<u32>::new();
        let a = pool.spawn(42);

        assert_eq!(pool.handle_from_index(0), a);
        assert_eq!(pool.handle_from_index(1), Handle::NONE);
    }

    #[test]
    fn pool_alive_count() {
        let mut pool = Pool::<u32>::new();
        let a = pool.spawn(42);
        let _ = pool.spawn(5);
        let (ticket, _) = pool.take_reserve(a);
        pool.forget_ticket(ticket);

        assert_eq!(pool.alive_count(), 1);
    }

    #[test]
    fn pool_total_count() {
        let mut pool = Pool::<u32>::new();
        let a = pool.spawn(42);
        let _ = pool.spawn(5);
        let (ticket, _) = pool.take_reserve(a);

        assert_eq!(pool.total_count(), 2);

        pool.forget_ticket(ticket);
    }

    #[test]
    fn pool_replace() {
        let mut pool = Pool::<u32>::new();
        let a = pool.spawn(42);
        let b = Handle::<u32>::new(1, 1);

        assert_eq!(pool.replace(a, 5), Some(42));
        assert_eq!(pool.replace(b, 5), None);
    }

    #[test]
    fn pool_pair_iter() {
        let pool = Pool::<u32>::new();

        let iter = pool.pair_iter();

        assert_eq!(iter.pool, &pool);
        assert_eq!(iter.current, 0);
    }

    #[test]
    fn pool_pair_iter_mut() {
        let mut pool = Pool::<u32>::new();
        let _ = pool.spawn(42);

        let iter = pool.pair_iter_mut();

        assert_eq!(iter.current, 0);
        assert_eq!(iter.ptr, pool.records.as_mut_ptr());
    }

    #[test]
    fn index_for_pool() {
        let mut pool = Pool::<u32>::new();
        let a = pool.spawn(42);
        let b = pool.spawn(5);

        assert_eq!(pool[a], 42);
        assert_eq!(pool[b], 5);
    }

    #[test]
    fn index_mut_for_pool() {
        let mut pool = Pool::<u32>::new();
        let a = pool.spawn(42);
        let b = pool.spawn(5);

        pool[a] = 15;

        assert_eq!(pool[a], 15);
        assert_eq!(pool[b], 5);
    }

    #[test]
    fn test_atomic_handle() {
        let handle = AtomicHandle::new(123, 321);
        assert!(handle.is_some());
        assert_eq!(handle.index(), 123);
        assert_eq!(handle.generation(), 321);

        let handle = AtomicHandle::default();
        assert!(handle.is_none());
    }

    #[test]
    fn test_generate_free_handles() {
        let mut pool = Pool::<u32>::new();

        let _ = pool.spawn(42);
        let b = pool.spawn(5);
        let _ = pool.spawn(228);

        pool.free(b);

        let h0 = Handle::new(1, 2);
        let h1 = Handle::new(3, 1);
        let h2 = Handle::new(4, 1);
        let h3 = Handle::new(5, 1);
        let h4 = Handle::new(6, 1);

        let free_handles = pool.generate_free_handles(5);
        assert_eq!(free_handles, [h0, h1, h2, h3, h4]);

        // Spawn something on the generated handles.
        for (i, handle) in free_handles.into_iter().enumerate() {
            let instance_handle = pool.spawn_at_handle(handle, i as u32);
            assert_eq!(instance_handle, Ok(handle));
        }

        assert_eq!(pool[h0], 0);
        assert_eq!(pool[h1], 1);
        assert_eq!(pool[h2], 2);
        assert_eq!(pool[h3], 3);
        assert_eq!(pool[h4], 4);
    }

    #[test]
    fn test_spawn_consistent_with_generate_free_handles() {
        let mut pool = Pool::<u32>::new();

        let _ = pool.spawn(42);
        let b0 = pool.spawn(5);
        let b1 = pool.spawn(6);
        let b2 = pool.spawn(7);
        let _ = pool.spawn(228);

        pool.free(b0);
        pool.free(b1);
        pool.free(b2);

        let free_handles = pool.generate_free_handles(5);

        let mut spawn_handles = Vec::new();
        for i in 0..5 {
            spawn_handles.push(pool.spawn(i));
        }

        assert_eq!(free_handles, spawn_handles);
    }
}


Path: ./src/pool/handle.rs

// Copyright (c) 2019-present Dmitry Stepanov and Fyrox Engine contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use crate::pool::INVALID_GENERATION;
use serde::{Deserialize, Serialize};
use std::any::{type_name, Any, TypeId};
use std::{
    cmp::Ordering,
    fmt::{Debug, Display, Formatter},
    hash::{Hash, Hasher},
    marker::PhantomData,
    sync::atomic::{self, AtomicUsize},
};

/// Handle is some sort of non-owning reference to content in a pool. It stores
/// index of object and additional information that allows to ensure that handle
/// is still valid (points to the same object as when handle was created).
#[derive(Serialize, Deserialize)]
pub struct Handle<T> {
    /// Index of object in pool.
    pub(super) index: u32,
    /// Generation number, if it is same as generation of pool record at
    /// index of handle then this is valid handle.
    pub(super) generation: u32,
    /// Type holder.
    #[serde(skip)]
    pub(super) type_marker: PhantomData<T>,
}

impl<T> Copy for Handle<T> {}

impl<T> Eq for Handle<T> {}

impl<T> PartialEq for Handle<T> {
    #[inline]
    fn eq(&self, other: &Handle<T>) -> bool {
        self.generation == other.generation && self.index == other.index
    }
}

impl<T> Hash for Handle<T> {
    #[inline]
    fn hash<H>(&self, state: &mut H)
    where
        H: Hasher,
    {
        self.index.hash(state);
        self.generation.hash(state);
    }
}

impl<T> Handle<T> {
    pub const NONE: Handle<T> = Handle {
        index: 0,
        generation: INVALID_GENERATION,
        type_marker: PhantomData,
    };

    #[inline(always)]
    pub fn is_none(self) -> bool {
        self.index == 0 && self.generation == INVALID_GENERATION
    }

    #[inline(always)]
    pub fn is_some(self) -> bool {
        !self.is_none()
    }

    #[inline(always)]
    pub fn index(self) -> u32 {
        self.index
    }

    #[inline(always)]
    pub fn generation(self) -> u32 {
        self.generation
    }

    #[inline(always)]
    pub fn new(index: u32, generation: u32) -> Self {
        Handle {
            index,
            generation,
            type_marker: PhantomData,
        }
    }

    #[inline(always)]
    pub fn transmute<U>(&self) -> Handle<U> {
        Handle {
            index: self.index,
            generation: self.generation,
            type_marker: Default::default(),
        }
    }

    #[inline(always)]
    pub fn decode_from_u128(num: u128) -> Self {
        Self {
            index: num as u32,
            generation: (num >> 32) as u32,
            type_marker: Default::default(),
        }
    }

    #[inline(always)]
    pub fn encode_to_u128(&self) -> u128 {
        (self.index as u128) | ((self.generation as u128) << 32)
    }
}

impl<T> PartialOrd for Handle<T> {
    #[inline]
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl<T> Ord for Handle<T> {
    #[inline]
    fn cmp(&self, other: &Self) -> Ordering {
        self.index.cmp(&other.index)
    }
}

unsafe impl<T> Send for Handle<T> {}
unsafe impl<T> Sync for Handle<T> {}

impl<T> Display for Handle<T> {
    #[inline]
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}:{}", self.index, self.generation)
    }
}

/// Atomic handle.
pub struct AtomicHandle(AtomicUsize);

impl Clone for AtomicHandle {
    #[inline]
    fn clone(&self) -> Self {
        Self(AtomicUsize::new(self.0.load(atomic::Ordering::Relaxed)))
    }
}

impl Default for AtomicHandle {
    #[inline]
    fn default() -> Self {
        Self::none()
    }
}

impl AtomicHandle {
    #[inline]
    pub fn none() -> Self {
        Self(AtomicUsize::new(0))
    }

    #[inline]
    pub fn new(index: u32, generation: u32) -> Self {
        let handle = Self(AtomicUsize::new(0));
        handle.set(index, generation);
        handle
    }

    #[inline]
    pub fn set(&self, index: u32, generation: u32) {
        let index = (index as usize) << (usize::BITS / 2) >> (usize::BITS / 2);
        let generation = (generation as usize) << (usize::BITS / 2);
        self.0.store(index | generation, atomic::Ordering::Relaxed);
    }

    #[inline]
    pub fn set_from_handle<T>(&self, handle: Handle<T>) {
        self.set(handle.index, handle.generation)
    }

    #[inline(always)]
    pub fn is_some(&self) -> bool {
        self.generation() != INVALID_GENERATION
    }

    #[inline(always)]
    pub fn is_none(&self) -> bool {
        !self.is_some()
    }

    #[inline]
    pub fn index(&self) -> u32 {
        let bytes = self.0.load(atomic::Ordering::Relaxed);
        ((bytes << (usize::BITS / 2)) >> (usize::BITS / 2)) as u32
    }

    #[inline]
    pub fn generation(&self) -> u32 {
        let bytes = self.0.load(atomic::Ordering::Relaxed);
        (bytes >> (usize::BITS / 2)) as u32
    }
}

impl Display for AtomicHandle {
    #[inline]
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}:{}", self.index(), self.generation())
    }
}

impl Debug for AtomicHandle {
    #[inline]
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "[Idx: {}; Gen: {}]", self.index(), self.generation())
    }
}

/// Type-erased handle.
#[derive(
    Copy, Clone, Debug, Ord, PartialOrd, PartialEq, Eq, Hash, Serialize, Deserialize,
)]
pub struct ErasedHandle {
    /// Index of object in pool.
    index: u32,
    /// Generation number, if it is same as generation of pool record at
    /// index of handle then this is valid handle.
    generation: u32,
}

impl Display for ErasedHandle {
    #[inline]
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}:{}", self.index, self.generation)
    }
}

impl Default for ErasedHandle {
    #[inline]
    fn default() -> Self {
        Self::none()
    }
}

impl<T> From<ErasedHandle> for Handle<T> {
    #[inline]
    fn from(erased_handle: ErasedHandle) -> Self {
        Handle {
            index: erased_handle.index,
            generation: erased_handle.generation,
            type_marker: PhantomData,
        }
    }
}

impl<T> From<AtomicHandle> for Handle<T> {
    #[inline]
    fn from(atomic_handle: AtomicHandle) -> Self {
        Handle {
            index: atomic_handle.index(),
            generation: atomic_handle.generation(),
            type_marker: PhantomData,
        }
    }
}

impl<T> From<Handle<T>> for ErasedHandle {
    #[inline]
    fn from(h: Handle<T>) -> Self {
        Self {
            index: h.index,
            generation: h.generation,
        }
    }
}

impl ErasedHandle {
    #[inline]
    pub fn none() -> Self {
        Self {
            index: 0,
            generation: INVALID_GENERATION,
        }
    }

    #[inline]
    pub fn new(index: u32, generation: u32) -> Self {
        Self { index, generation }
    }

    #[inline(always)]
    pub fn is_some(&self) -> bool {
        self.generation != INVALID_GENERATION
    }

    #[inline(always)]
    pub fn is_none(&self) -> bool {
        !self.is_some()
    }

    #[inline(always)]
    pub fn index(self) -> u32 {
        self.index
    }

    #[inline(always)]
    pub fn generation(self) -> u32 {
        self.generation
    }
}

impl<T> Default for Handle<T> {
    #[inline]
    fn default() -> Self {
        Self::NONE
    }
}

impl<T> Debug for Handle<T> {
    #[inline]
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "[Idx: {}; Gen: {}]", self.index, self.generation)
    }
}

#[cfg(test)]
mod test {
    use crate::pool::{AtomicHandle, ErasedHandle, Handle, INVALID_GENERATION};

    #[test]
    fn test_handle_u128_encode_decode() {
        let a = Handle::<()>::new(123, 321);
        let encoded = a.encode_to_u128();
        let decoded = Handle::<()>::decode_from_u128(encoded);
        assert_eq!(decoded, a);
    }

    #[test]
    fn erased_handle_none() {
        assert_eq!(
            ErasedHandle::none(),
            ErasedHandle {
                index: 0,
                generation: INVALID_GENERATION,
            }
        );
    }

    #[test]
    fn erased_handle_new() {
        assert_eq!(
            ErasedHandle::new(0, 1),
            ErasedHandle {
                index: 0,
                generation: 1,
            }
        );
    }

    #[test]
    fn erased_handle_is_some() {
        assert!(ErasedHandle::new(0, 1).is_some());
        assert!(!ErasedHandle::none().is_some());
    }

    #[test]
    fn erased_handle_is_none() {
        assert!(!ErasedHandle::new(0, 1).is_none());
        assert!(ErasedHandle::none().is_none());
    }

    #[test]
    fn erased_handle_index() {
        assert_eq!(
            ErasedHandle {
                index: 42,
                generation: 15
            }
            .index(),
            42
        );
    }

    #[test]
    fn erased_handle_generation() {
        assert_eq!(
            ErasedHandle {
                index: 42,
                generation: 15
            }
            .generation(),
            15
        );
    }

    #[test]
    fn default_for_erased_handle() {
        assert_eq!(ErasedHandle::default(), ErasedHandle::none());
    }

    #[test]
    fn erased_handle_from_handle() {
        let handle = Handle::<u32> {
            index: 0,
            generation: 1,
            type_marker: std::marker::PhantomData,
        };

        assert_eq!(
            ErasedHandle::from(handle),
            ErasedHandle {
                index: 0,
                generation: 1
            }
        );
    }

    #[test]
    fn handle_from_erased_handle() {
        let er = ErasedHandle {
            index: 0,
            generation: 1,
        };

        assert_eq!(
            Handle::from(er),
            Handle::<u32> {
                index: 0,
                generation: 1,
                type_marker: std::marker::PhantomData,
            }
        );
    }

    #[test]
    fn default_for_handle() {
        assert_eq!(Handle::default(), Handle::<u32>::NONE);
    }

    #[test]
    fn test_debug_for_handle() {
        let h = Handle::<u32> {
            index: 0,
            generation: 1,
            type_marker: std::marker::PhantomData,
        };

        assert_eq!(format!("{h:?}"), "[Idx: 0; Gen: 1]");
    }

    #[test]
    fn handle_getters() {
        let h = Handle::<u32> {
            index: 0,
            generation: 1,
            type_marker: std::marker::PhantomData,
        };

        assert_eq!(h.index(), 0);
        assert_eq!(h.generation(), 1);
    }

    #[test]
    fn handle_transmute() {
        assert_eq!(
            Handle::<u32>::default().transmute::<f32>(),
            Handle::<f32>::default()
        );
    }

    #[test]
    fn test_atomic_handle() {
        let handle = AtomicHandle::new(123, 321);
        assert!(handle.is_some());
        assert_eq!(handle.index(), 123);
        assert_eq!(handle.generation(), 321);

        let handle = AtomicHandle::default();
        assert!(handle.is_none());
    }
}


Path: ./src/pool/payload.rs

// Copyright (c) 2019-present Dmitry Stepanov and Fyrox Engine contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use std::cell::UnsafeCell;

pub trait PayloadContainer: Sized {
    type Element: Sized;

    fn new_empty() -> Self;

    fn new(element: Self::Element) -> Self;

    fn is_some(&self) -> bool;

    fn as_ref(&self) -> Option<&Self::Element>;

    fn as_mut(&mut self) -> Option<&mut Self::Element>;

    fn replace(&mut self, element: Self::Element) -> Option<Self::Element>;

    fn take(&mut self) -> Option<Self::Element>;
}

impl<T> PayloadContainer for Option<T> {
    type Element = T;

    #[inline]
    fn new_empty() -> Self {
        Self::None
    }

    #[inline]
    fn new(element: Self::Element) -> Self {
        Self::Some(element)
    }

    #[inline]
    fn is_some(&self) -> bool {
        Option::is_some(self)
    }

    #[inline]
    fn as_ref(&self) -> Option<&Self::Element> {
        Option::as_ref(self)
    }

    #[inline]
    fn as_mut(&mut self) -> Option<&mut Self::Element> {
        Option::as_mut(self)
    }

    #[inline]
    fn replace(&mut self, element: Self::Element) -> Option<Self::Element> {
        Option::replace(self, element)
    }

    #[inline]
    fn take(&mut self) -> Option<Self::Element> {
        Option::take(self)
    }
}

#[derive(Debug)]
pub struct Payload<P>(pub UnsafeCell<P>);

impl<T, P> Clone for Payload<P>
where
    T: Sized,
    P: PayloadContainer<Element = T> + Clone,
{
    fn clone(&self) -> Self {
        Self(UnsafeCell::new(self.get().clone()))
    }
}

impl<T, P> Payload<P>
where
    T: Sized,
    P: PayloadContainer<Element = T>,
{
    pub fn new(data: T) -> Self {
        Self(UnsafeCell::new(P::new(data)))
    }

    pub fn new_empty() -> Self {
        Self(UnsafeCell::new(P::new_empty()))
    }

    pub fn get(&self) -> &P {
        unsafe { &*self.0.get() }
    }

    pub fn get_mut(&mut self) -> &mut P {
        self.0.get_mut()
    }

    pub fn is_some(&self) -> bool {
        self.get().is_some()
    }

    pub fn as_ref(&self) -> Option<&T> {
        self.get().as_ref()
    }

    pub fn as_mut(&mut self) -> Option<&mut T> {
        self.get_mut().as_mut()
    }

    pub fn replace(&mut self, element: T) -> Option<T> {
        self.get_mut().replace(element)
    }

    pub fn take(&mut self) -> Option<T> {
        self.get_mut().take()
    }
}

// SAFETY: This is safe, because Payload is never directly exposed to the call site. It is always
// accessed using a sort of read-write lock that forces borrowing rules at runtime.
unsafe impl<T, P> Sync for Payload<P>
where
    T: Sized,
    P: PayloadContainer<Element = T>,
{
}

// SAFETY: This is safe, because Payload is never directly exposed to the call site. It is always
// accessed using a sort of read-write lock that forces borrowing rules at runtime.
unsafe impl<T, P> Send for Payload<P>
where
    T: Sized,
    P: PayloadContainer<Element = T>,
{
}


Path: ./src/buffer.rs

use std::ops::{Deref, DerefMut};
use std::time::Duration;

#[derive(Debug)]
pub enum DataSource {
    /// Raw samples in interleaved format with specified sample rate and channel count. Can be used for procedural
    /// sounds.
    /// # Notes
    /// Cannot be used with streaming buffers - it makes no sense to stream data that is already loaded into memory.
    Raw {
        sample_rate: usize,
        /// Total amount of channels.
        channel_count: usize,
        /// Raw samples in interleaved format. Count of samples must be multiple to channel count, otherwise you'll
        /// get error at attempt to use such buffer.
        samples: Vec<f32>,
    },
}

#[derive(Debug, Default, Clone)]
pub struct Samples(pub Vec<f32>);

impl Deref for Samples {
    type Target = Vec<f32>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for Samples {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

#[derive(Debug, Default, Clone)]
pub struct Buffer {
    /// Interleaved decoded samples (mono sounds: L..., stereo sounds: LR...)
    pub samples: Samples,
    pub channel_count: usize,
    pub sample_rate: usize,
    pub channel_duration_in_samples: usize,
}

impl Buffer {
    /// Data source with raw samples must have sample count multiple of channel count
    pub fn new(source: DataSource) -> anyhow::Result<Self> {
        match source {
            DataSource::Raw {
                sample_rate,
                channel_count,
                samples,
            } => {
                if channel_count < 1 || channel_count > 2 || samples.len() % channel_count != 0 {
                    Err(anyhow::anyhow!(
                        "Channel count != 1 or 2, found: {channel_count}"
                    ))
                } else if samples.len() % channel_count != 0 {
                    Err(anyhow::anyhow!(
                        "Every channel must have a sample, samples % channel_count = {}",
                        samples.len() % channel_count
                    ))
                } else {
                    Ok(Self {
                        channel_duration_in_samples: samples.len() / channel_count,
                        samples: Samples(samples),
                        channel_count,
                        sample_rate,
                    })
                }
            }
        }
    }

    /// Returns exact time length of the buffer.
    #[inline]
    pub fn duration(&self) -> Duration {
        Duration::from_nanos(
            (self.channel_duration_in_samples as u64 * 1_000_000_000u64) / self.sample_rate as u64,
        )
    }
}


Path: ./Cargo.toml

[package]
name = "audio"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[features]

[dependencies]
hound = "3.4.0"
strum = "0.26.1"
strum_macros = "0.26.1"
tinyaudio = "1"
serde = { version = "1", features = ["derive"] }
anyhow = "1.0.98"
glam = "0.30.3"


